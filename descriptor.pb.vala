// Generated by protoc-gen-vala from google/protobuf/descriptor.proto, do not edit

public class FileDescriptorSet
{
    public List<FileDescriptorProto> file;

    public FileDescriptorSet.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                file.append (new FileDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        foreach (var v in file)
        {
            // ...
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }
}

public class FileDescriptorProto
{
    public string? name;
    public string? package;
    public List<string> dependency;
    public List<DescriptorProto> message_type;
    public List<EnumDescriptorProto> enum_type;
    public List<ServiceDescriptorProto> service;
    public List<FieldDescriptorProto> extension;
    public FileOptions? options;
    public SourceCodeInfo? source_code_info;

    public FileDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                package = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 3:
                dependency.append (Protobuf.decode_string (buffer, offset + value_length, offset));
                break;
            case 4:
                message_type.append (new DescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 5:
                enum_type.append (new EnumDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 6:
                service.append (new ServiceDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 7:
                extension.append (new FieldDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 8:
                options = new FileOptions.from_data (buffer, offset + value_length, offset);
                break;
            case 9:
                source_code_info = new SourceCodeInfo.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of FileDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        if (source_code_info != null)
        {
            // ...
            Protobuf.encode_varint (72, buffer, ref offset);
        }
        if (options != null)
        {
            // ...
            Protobuf.encode_varint (64, buffer, ref offset);
        }
        foreach (var v in extension)
        {
            // ...
            Protobuf.encode_varint (56, buffer, ref offset);
        }
        foreach (var v in service)
        {
            // ...
            Protobuf.encode_varint (48, buffer, ref offset);
        }
        foreach (var v in enum_type)
        {
            // ...
            Protobuf.encode_varint (40, buffer, ref offset);
        }
        foreach (var v in message_type)
        {
            // ...
            Protobuf.encode_varint (32, buffer, ref offset);
        }
        foreach (var v in dependency)
        {
            Protobuf.encode_string (v, buffer, ref offset);
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        if (package != null)
        {
            Protobuf.encode_string (package, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (name != null)
        {
            Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }

        return 0;
    }

    public string to_string ()
    {
        var value = "";

        if (name != null)
            value += "name=\"%s\" ".printf (name);
        if (package != null)
            value += "package=\"%s\" ".printf (package);

        if (dependency != null)
        {
            value += "dependency=[";
            foreach (var v in dependency)
                value += "\"%s\" ".printf (v);
            value += "] ";
        }

        if (message_type != null)
        {
            value += "message_type=[";
            foreach (var v in message_type)
                value += "{ %s} ".printf (v.to_string ());
            value += "] ";
        }

        if (options != null)
            value += "options={ %s} ".printf (options.to_string ());

        return value;
    }
}

public class DescriptorProto
{
    public class ExtensionRange
    {
        public int32? start;
        public int32? end;

        public ExtensionRange.from_data (uint8[] buffer, size_t length, size_t offset = 0)
        {
            decode (buffer, length, offset);
        }

        public void decode (uint8[] buffer, size_t length, size_t offset = 0)
        {
            while (offset < length)
            {
                var key = Protobuf.decode_varint (buffer, length, ref offset);
                var wire_type = key & 0x7;
                var field_number = key >> 3;
                int varint;
                var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
                // FIXME: Check remaining space

                switch (field_number)
                {
                case 1:
                    start = varint;
                    break;
                case 2:
                    end = varint;
                    break;
                }

                offset += value_length;
            }

            if (offset != length)
                stderr.printf ("Unused %zu octets on end of DescriptorProto.ExtensionRange\n", offset - length);
        }

        public size_t encode (uint8[] buffer, size_t offset)
        {
            if (end != null)
            {
                // ...
                Protobuf.encode_varint (16, buffer, ref offset);
            }
            if (start != null)
            {
                // ...
                Protobuf.encode_varint (8, buffer, ref offset);
            }
            return 0;
        }
    }

    public string? name;
    public List<FieldDescriptorProto> field;
    public List<FieldDescriptorProto> extension;
    public List<DescriptorProto> nested_type;
    public List<EnumDescriptorProto> enum_type;
    public List<ExtensionRange> extension_range;
    public MessageOptions? options;

    public DescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                field.append (new FieldDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 6:
                extension.append (new FieldDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                nested_type.append (new DescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 4:
                enum_type.append (new EnumDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 5:
                extension_range.append (new ExtensionRange.from_data (buffer, offset + value_length, offset));
                break;
            case 7:
                options = new MessageOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of DescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        if (options != null)
        {
            // ...
            Protobuf.encode_varint (56, buffer, ref offset);
        }
        foreach (var v in extension_range)
        {
            // ...
            Protobuf.encode_varint (40, buffer, ref offset);
        }
        foreach (var v in enum_type)
        {
            // ...
            Protobuf.encode_varint (32, buffer, ref offset);
        }
        foreach (var v in nested_type)
        {
            // ...
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        foreach (var v in extension)
        {
            // ...
            Protobuf.encode_varint (48, buffer, ref offset);
        }
        foreach (var v in field)
        {
            // ...
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (name != null)
        {
            Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }

    public string to_string ()
    {
        var value = "";

        if (name != null)
            value += "name=\"%s\" ".printf (name);

        if (field != null)
        {
            value += "field=[";
            foreach (var v in field)
                value += "{ %s} ".printf (v.to_string ());
            value += "] ";
        }

        if (extension != null)
        {
            value += "extension=[";
            foreach (var v in extension)
                value += "{ %s} ".printf (v.to_string ());
            value += "] ";
        }

        if (nested_type != null)
        {
            value += "nested_type=[";
            foreach (var v in nested_type)
                value += "{ %s} ".printf (v.to_string ());
            value += "] ";
        }

        if (enum_type != null)
        {
            value += "enum_type=[";
            foreach (var v in enum_type)
                value += "{ %s} ".printf (v.to_string ());
            value += "] ";
        }

        return value;
    }
}

public class FieldDescriptorProto
{
    public enum Type
    {
        TYPE_DOUBLE = 1,
        TYPE_FLOAT = 2,
        TYPE_INT64 = 3,
        TYPE_UINT64 = 4,
        TYPE_INT32 = 5,
        TYPE_FIXED64 = 6,
        TYPE_FIXED32 = 7,
        TYPE_BOOL = 8,
        TYPE_STRING = 9,
        TYPE_GROUP = 10,
        TYPE_MESSAGE = 11,
        TYPE_BYTES = 12,
        TYPE_UINT32 = 13,
        TYPE_ENUM = 14,
        TYPE_SFIXED32 = 15,
        TYPE_SFIXED64 = 16,
        TYPE_SINT32 = 17,
        TYPE_SINT64 = 18,
    }

    public string type_to_string (Type type)
    {
        switch (type)
        {
        case Type.TYPE_DOUBLE:
            return "TYPE_DOUBLE";
        case Type.TYPE_FLOAT:
            return "TYPE_FLOAT";
        case Type.TYPE_INT64:
            return "TYPE_INT64";
        case Type.TYPE_UINT64:
            return "TYPE_UINT64";
        case Type.TYPE_INT32:
            return "TYPE_INT32";
        case Type.TYPE_FIXED64:
            return "TYPE_FIXED64";
        case Type.TYPE_FIXED32:
            return "TYPE_FIXED32";
        case Type.TYPE_BOOL:
            return "TYPE_BOOL";
        case Type.TYPE_STRING:
            return "TYPE_STRING";
        case Type.TYPE_GROUP:
            return "TYPE_GROUP";
        case Type.TYPE_MESSAGE:
            return "TYPE_MESSAGE";
        case Type.TYPE_BYTES:
            return "TYPE_BYTES";
        case Type.TYPE_UINT32:
            return "TYPE_UINT32";
        case Type.TYPE_ENUM:
            return "TYPE_ENUM";
        case Type.TYPE_SFIXED32:
            return "TYPE_SFIXED32";
        case Type.TYPE_SFIXED64:
            return "TYPE_SFIXED64";
        case Type.TYPE_SINT32:
            return "TYPE_SINT32";
        case Type.TYPE_SINT64:
            return "TYPE_SINT64";
        default:
            return "%d".printf (type);
        }
    }

    public enum Label
    {
        LABEL_OPTIONAL = 1,
        LABEL_REQUIRED = 2,
        LABEL_REPEATED = 3,
    }

    public string label_to_string (Label label)
    {
        switch (label)
        {
        case Label.LABEL_OPTIONAL:
            return "LABEL_OPTIONAL";
        case Label.LABEL_REQUIRED:
            return "LABEL_REQUIRED";
        case Label.LABEL_REPEATED:
            return "LABEL_REPEATED";
        default:
            return "%d".printf (label);
        }
    }

    public string? name;
    public int32? number;
    public Label? label;
    public Type? type;
    public string? type_name;
    public string? extendee;
    public string? default_value;
    public FieldOptions? options;

    public FieldDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 3:
                number = varint;
                break;
            case 4:
                label = (Label) varint;
                break;
            case 5:
                type = (Type) varint;
                break;
            case 6:
                type_name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                extendee = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 7:
                default_value = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 8:
                options = new FieldOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of FieldDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        if (options != null)
        {
            // ...
            Protobuf.encode_varint (64, buffer, ref offset);
        }
        if (default_value != null)
        {
            Protobuf.encode_string (default_value, buffer, ref offset);
            Protobuf.encode_varint (56, buffer, ref offset);
        }
        if (extendee != null)
        {
            Protobuf.encode_string (extendee, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (type_name != null)
        {
            Protobuf.encode_string (type_name, buffer, ref offset);
            Protobuf.encode_varint (48, buffer, ref offset);
        }
        if (type != null)
        {
            // ...
            Protobuf.encode_varint (40, buffer, ref offset);
        }
        if (label != null)
        {
            // ...
            Protobuf.encode_varint (32, buffer, ref offset);
        }
        if (number != null)
        {
            // ...
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        if (name != null)
        {
            Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }

    public string to_string ()
    {
        var text = "";
        
        if (name != null)
            text += "name=\"%s\" ".printf (name);
        if (number != null)
            text += "number=%d ".printf (number);
        if (label != null)
            text += "label=%s ".printf (label_to_string (label));
        if (type != null)
            text += "type=%s ".printf (type_to_string (type));
        if (type_name != null)
            text += "type_name=\"%s\" ".printf (type_name);
        if (default_value != null)
            text += "default_value=\"%s\" ".printf (default_value);
        if (options != null)
            text += "options={ %s} ".printf (options.to_string ());

        return text;
    }
}

public class EnumDescriptorProto
{
    public string? name;
    public List<EnumValueDescriptorProto> value;
    public EnumOptions? options;

    public EnumDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                value.append (new EnumValueDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                options = new EnumOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of EnumDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        if (options != null)
        {
            // ...
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        foreach (var v in value)
        {
            // ...
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (name != null)
        {
            Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }

    public string to_string ()
    {
        var text = "";
        
        if (name != null)
            text += "name=\"%s\" ".printf (name);
        
        text += "value=[";
        foreach (var v in value)
            text += "{ %s} ".printf (v.to_string ());
        text += "] ";

        return text;
    }
}

public class EnumValueDescriptorProto
{
    public string? name;
    public int32? number;
    public EnumValueOptions? options;

    public EnumValueDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                number = varint;
                break;
            case 3:
                options = new EnumValueOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of EnumValueDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        if (options != null)
        {
            // ...
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        if (number != null)
        {
            // ...
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (name != null)
        {
            Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }

    public string to_string ()
    {
        var text = "";
        
        if (name != null)
            text += "name=\"%s\" ".printf (name);
        if (number != null)
            text += "number=%d ".printf (number);

        return text;
    }
}

public class ServiceDescriptorProto
{
    public string? name;
    public List<MethodDescriptorProto> method;
    public ServiceOptions? options;

    public ServiceDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                method.append (new MethodDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                options = new ServiceOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        if (options != null)
        {
            // ...
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        foreach (var v in method)
        {
            // ...
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (name != null)
        {
            Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }
}

public class MethodDescriptorProto
{
    public string? name;
    public string? input_type;
    public string? output_type;
    public MethodOptions? options;

    public MethodDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                input_type = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 3:
                output_type = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 4:
                options = new MethodOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        if (options != null)
        {
            // ...
            Protobuf.encode_varint (32, buffer, ref offset);
        }
        if (output_type != null)
        {
            Protobuf.encode_string (output_type, buffer, ref offset);
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        if (input_type != null)
        {
            Protobuf.encode_string (input_type, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (name != null)
        {
            Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }
}

public class FileOptions
{
    public enum OptimizeMode
    {
        SPEED = 1,
        CODE_SIZE = 2,
        LITE_RUNTIME = 3,
    }

    private string optimize_mode_to_string (OptimizeMode mode)
    {
        switch (mode)
        {
        case OptimizeMode.SPEED:
            return "SPEED";
        case OptimizeMode.CODE_SIZE:
            return "CODE_SIZE";
        case OptimizeMode.LITE_RUNTIME:
            return "LITE_RUNTIME";
        default:
            return "%d".printf (mode);
        }
    }

    public string? java_package;
    public string? java_outer_classname;
    public bool? java_multiple_files;
    public bool? java_generate_equals_and_hash;
    public OptimizeMode? optimize_for;
    public bool? cc_generic_services;
    public bool? java_generic_services;
    public bool? py_generic_services;
    public List<UninterpretedOption> uninterpreted_option;

    public FileOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                java_package = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 8:
                java_outer_classname = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 10:
                java_multiple_files = varint != 0;
                break;
            case 20:
                java_generate_equals_and_hash = varint != 0;
                break;
            case 9:
                optimize_for = (OptimizeMode) varint;
                break;
            case 16:
                cc_generic_services = varint != 0;
                break;
            case 17:
                java_generic_services = varint != 0;
                break;
            case 18:
                py_generic_services = varint != 0;
                break;
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of EnumValueDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        foreach (var v in uninterpreted_option)
        {
            // ...
            Protobuf.encode_varint (7992, buffer, ref offset);
        }
        if (py_generic_services != null)
        {
            Protobuf.encode_varint (py_generic_services ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (144, buffer, ref offset);
        }
        if (java_generic_services != null)
        {
            Protobuf.encode_varint (java_generic_services ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (136, buffer, ref offset);
        }
        if (cc_generic_services != null)
        {
            Protobuf.encode_varint (cc_generic_services ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (128, buffer, ref offset);
        }
        if (optimize_for != null)
        {
            // ...
            Protobuf.encode_varint (72, buffer, ref offset);
        }
        if (java_generate_equals_and_hash != null)
        {
            Protobuf.encode_varint (java_generate_equals_and_hash ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (160, buffer, ref offset);
        }
        if (java_multiple_files != null)
        {
            Protobuf.encode_varint (java_multiple_files ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (80, buffer, ref offset);
        }
        if (java_outer_classname != null)
        {
            Protobuf.encode_string (java_outer_classname, buffer, ref offset);
            Protobuf.encode_varint (64, buffer, ref offset);
        }
        if (java_package != null)
        {
            Protobuf.encode_string (java_package, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }

    public string to_string ()
    {
        var text = "";

        if (java_package != null)
            text += "java_package=\"%s\" ".printf (java_package);
        if (java_outer_classname != null)
            text += "java_outer_classname=\"%s\" ".printf (java_outer_classname);
        if (optimize_for != null)
            text += "optimize_for=%s ".printf (optimize_mode_to_string (optimize_for));

        return text;
    }
}

public class MessageOptions
{
    public bool? message_set_wire_format;
    public bool? no_standard_descriptor_accessor;
    public List<UninterpretedOption> uninterpreted_option;

    public MessageOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                message_set_wire_format = varint != 0;
                break;
            case 2:
                no_standard_descriptor_accessor = varint != 0;
                break;
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        foreach (var v in uninterpreted_option)
        {
            // ...
            Protobuf.encode_varint (7992, buffer, ref offset);
        }
        if (no_standard_descriptor_accessor != null)
        {
            Protobuf.encode_varint (no_standard_descriptor_accessor ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (message_set_wire_format != null)
        {
            Protobuf.encode_varint (message_set_wire_format ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }
}

public class FieldOptions
{
    public enum CType
    {
        STRING = 0,
        CORD = 1,
        STRING_PIECE = 2,
    }

    public CType? ctype;
    public bool? packed;
    public bool? deprecated;
    public string? experimental_map_key;
    public List<UninterpretedOption> uninterpreted_option;

    public FieldOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                ctype = (CType) varint;
                break;
            case 2:
                packed = varint != 0;
                break;
            case 3:
                deprecated = varint != 0;
                break;
            case 9:
                experimental_map_key = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of FieldOptions\n", offset - length);
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        foreach (var v in uninterpreted_option)
        {
            // ...
            Protobuf.encode_varint (7992, buffer, ref offset);
        }
        if (experimental_map_key != null)
        {
            Protobuf.encode_string (experimental_map_key, buffer, ref offset);
            Protobuf.encode_varint (72, buffer, ref offset);
        }
        if (deprecated != null)
        {
            Protobuf.encode_varint (deprecated ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        if (packed != null)
        {
            // ...
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (ctype != null)
        {
            // ...
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }

    public string to_string ()
    {
        var text = "";

        if (packed != null)
            text += "packed=%s ".printf (packed ? "true" : "false");

        return text;
    }
}

public class EnumOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public EnumOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        foreach (var v in uninterpreted_option)
        {
            // ...
            Protobuf.encode_varint (7992, buffer, ref offset);
        }
        return 0;
    }
}

public class EnumValueOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public EnumValueOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        foreach (var v in uninterpreted_option)
        {
            // ...
            Protobuf.encode_varint (7992, buffer, ref offset);
        }
        return 0;
    }
}

public class ServiceOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public ServiceOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        foreach (var v in uninterpreted_option)
        {
            // ...
            Protobuf.encode_varint (7992, buffer, ref offset);
        }
        return 0;
    }
}

public class MethodOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public MethodOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        foreach (var v in uninterpreted_option)
        {
            // ...
            Protobuf.encode_varint (7992, buffer, ref offset);
        }
        return 0;
    }
}

public class UninterpretedOption
{
    public class NamePart
    {
        public string name_part;
        public bool is_extension;

        public NamePart.from_data (uint8[] buffer, size_t length, size_t offset = 0)
        {
            decode (buffer, length, offset);
        }

        public void decode (uint8[] buffer, size_t length, size_t offset = 0)
        {
            while (offset < length)
            {
                var key = Protobuf.decode_varint (buffer, length, ref offset);
                var wire_type = key & 0x7;
                var field_number = key >> 3;
                int varint;
                var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
                // FIXME: Check remaining space

                switch (field_number)
                {
                case 1:
                    name_part = Protobuf.decode_string (buffer, offset + value_length, offset);
                    break;
                case 2:
                    is_extension = varint != 0;
                    break;
                }

                offset += value_length;
            }
        }

        public size_t encode (uint8[] buffer, size_t offset)
        {
            Protobuf.encode_varint (is_extension ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
            Protobuf.encode_string (name_part, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
            return 0;
        }
    }
    public List<NamePart> name;
    public string? identifier_value;
    public uint64? positive_int_value;
    public int64? negative_int_value;
    public double? double_value;
    public uint8[]? string_value;
    public string? aggregate_value;

    public UninterpretedOption.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 2:
                name.append (new NamePart.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                identifier_value = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 4:
                break;
            case 5:
                break;
            case 6:
                break;
            case 7:
                string_value = Protobuf.decode_bytes (buffer, offset + value_length, offset);
                break;
            case 8:
                aggregate_value = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        if (aggregate_value != null)
        {
            Protobuf.encode_string (aggregate_value, buffer, ref offset);
            Protobuf.encode_varint (64, buffer, ref offset);
        }
        if (string_value != null)
        {
            // ...
            Protobuf.encode_varint (56, buffer, ref offset);
        }
        if (double_value != null)
        {
            // ...
            Protobuf.encode_varint (48, buffer, ref offset);
        }
        if (negative_int_value != null)
        {
            // ...
            Protobuf.encode_varint (40, buffer, ref offset);
        }
        if (positive_int_value != null)
        {
            // ...
            Protobuf.encode_varint (32, buffer, ref offset);
        }
        if (identifier_value != null)
        {
            // ...
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        foreach (var v in name)
        {
            // ...
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        return 0;
    }
}

public class SourceCodeInfo
{
    public class Location
    {
        public List<int32> path;
        public List<int32> span;

        public Location.from_data (uint8[] buffer, size_t length, size_t offset = 0)
        {
            decode (buffer, length, offset);
        }

        public void decode (uint8[] buffer, size_t length, size_t offset = 0)
        {
            while (offset < length)
            {
                var key = Protobuf.decode_varint (buffer, length, ref offset);
                var wire_type = key & 0x7;
                var field_number = key >> 3;
                int varint;
                var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
                // FIXME: Check remaining space

                switch (field_number)
                {
                case 1:
                    path.append (varint);
                    break;
                case 2:
                    span.append (varint);
                    break;
                }

                offset += value_length;
            }
        }

        public size_t encode (uint8[] buffer, size_t offset)
        {
            foreach (var v in span)
            {
                // ...
                Protobuf.encode_varint (16, buffer, ref offset);
            }
            foreach (var v in path)
            {
                // ...
                Protobuf.encode_varint (8, buffer, ref offset);
            }
            return 0;
        }
    }
    public List<Location> location;

    public SourceCodeInfo.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                location.append (new Location.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, size_t offset)
    {
        foreach (var v in location)
        {
            // ...
            Protobuf.encode_varint (8, buffer, ref offset);
        }
        return 0;
    }
}