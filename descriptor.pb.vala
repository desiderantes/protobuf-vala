// Generated by protoc-gen-vala from google/protobuf/descriptor.proto, do not edit

public class FileDescriptorSet
{
    public List<FileDescriptorProto> file;

    public FileDescriptorSet.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                file.append (new FileDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<FileDescriptorProto> i = file.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (file != null)
        {
            text += "file=";
            foreach (var v in file)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class FileDescriptorProto
{
    public string? name;
    public string? package;
    public List<string> dependency;
    public List<DescriptorProto> message_type;
    public List<EnumDescriptorProto> enum_type;
    public List<ServiceDescriptorProto> service;
    public List<FieldDescriptorProto> extension;
    public FileOptions? options;
    public SourceCodeInfo? source_code_info;

    public FileDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                package = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 3:
                dependency.append (Protobuf.decode_string (buffer, offset + value_length, offset));
                break;
            case 4:
                message_type.append (new DescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 5:
                enum_type.append (new EnumDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 6:
                service.append (new ServiceDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 7:
                extension.append (new FieldDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 8:
                options = new FileOptions.from_data (buffer, offset + value_length, offset);
                break;
            case 9:
                source_code_info = new SourceCodeInfo.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of FileDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (source_code_info != null)
        {
            var n = source_code_info.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (74, buffer, ref offset);
        }
        if (options != null)
        {
            var n = options.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (66, buffer, ref offset);
        }
        for (unowned List<FieldDescriptorProto> i = extension.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (58, buffer, ref offset);
        }
        for (unowned List<ServiceDescriptorProto> i = service.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (50, buffer, ref offset);
        }
        for (unowned List<EnumDescriptorProto> i = enum_type.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (42, buffer, ref offset);
        }
        for (unowned List<DescriptorProto> i = message_type.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (34, buffer, ref offset);
        }
        for (unowned List<string> i = dependency.last (); i != null; i = i.prev)
        {
            var n = Protobuf.encode_string (i.data, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        if (package != null)
        {
            var n = Protobuf.encode_string (package, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (name != null)
        {
            var n = Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (name != null)
        {
            text += "name=";
            text += "\"%s\";\n".printf (name);
        }

        if (package != null)
        {
            text += "package=";
            text += "\"%s\";\n".printf (package);
        }

        if (dependency != null)
        {
            text += "dependency=";
            foreach (var v in dependency)
                text += "\"%s\";\n".printf (v);
        }

        if (message_type != null)
        {
            text += "message_type=";
            foreach (var v in message_type)
                text += "%s;\n".printf (v.to_string ());
        }

        if (enum_type != null)
        {
            text += "enum_type=";
            foreach (var v in enum_type)
                text += "%s;\n".printf (v.to_string ());
        }

        if (service != null)
        {
            text += "service=";
            foreach (var v in service)
                text += "%s;\n".printf (v.to_string ());
        }

        if (extension != null)
        {
            text += "extension=";
            foreach (var v in extension)
                text += "%s;\n".printf (v.to_string ());
        }

        if (options != null)
        {
            text += "options=";
            text += "%s;\n".printf (options.to_string ());
        }

        if (source_code_info != null)
        {
            text += "source_code_info=";
            text += "%s;\n".printf (source_code_info.to_string ());
        }

        text += "}";
        return text;
    }
}

public class DescriptorProto
{
    public class ExtensionRange
    {
        public int32? start;
        public int32? end;

        public ExtensionRange.from_data (uint8[] buffer, size_t length, size_t offset = 0)
        {
            decode (buffer, length, offset);
        }

        public void decode (uint8[] buffer, size_t length, size_t offset = 0)
        {
            while (offset < length)
            {
                var key = Protobuf.decode_varint (buffer, length, ref offset);
                var wire_type = key & 0x7;
                var field_number = key >> 3;
                int varint;
                var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
                // FIXME: Check remaining space

                switch (field_number)
                {
                case 1:
                    start = varint;
                    break;
                case 2:
                    end = varint;
                    break;
                }

                offset += value_length;
            }

            if (offset != length)
                stderr.printf ("Unused %zu octets on end of DescriptorProto.ExtensionRange\n", offset - length);
        }

        public size_t encode (uint8[] buffer, ref size_t offset)
        {
            var start = offset;

            if (end != null)
            {
                Protobuf.encode_varint (end, buffer, ref offset);
                Protobuf.encode_varint (16, buffer, ref offset);
            }
            if (this.start != null)
            {
                Protobuf.encode_varint (start, buffer, ref offset);
                Protobuf.encode_varint (8, buffer, ref offset);
            }

            return start - offset;
        }

        public string to_string (string indent = "")
        {
            var text = "{\n";

            if (start != null)
            {
                text += "start=";
                text += "%s;\n".printf (start.to_string ());
            }

            if (end != null)
            {
                text += "end=";
                text += "%s;\n".printf (end.to_string ());
            }

            text += "}";
            return text;
        }
    }

    public string? name;
    public List<FieldDescriptorProto> field;
    public List<FieldDescriptorProto> extension;
    public List<DescriptorProto> nested_type;
    public List<EnumDescriptorProto> enum_type;
    public List<ExtensionRange> extension_range;
    public MessageOptions? options;

    public DescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                field.append (new FieldDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 6:
                extension.append (new FieldDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                nested_type.append (new DescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 4:
                enum_type.append (new EnumDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 5:
                extension_range.append (new ExtensionRange.from_data (buffer, offset + value_length, offset));
                break;
            case 7:
                options = new MessageOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of DescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (options != null)
        {
            var n = options.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (58, buffer, ref offset);
        }
        for (unowned List<ExtensionRange> i = extension_range.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (42, buffer, ref offset);
        }
        for (unowned List<EnumDescriptorProto> i = enum_type.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (34, buffer, ref offset);
        }
        for (unowned List<DescriptorProto> i = nested_type.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        for (unowned List<FieldDescriptorProto> i = extension.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (50, buffer, ref offset);
        }
        for (unowned List<FieldDescriptorProto> i = field.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (name != null)
        {
            var n = Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (name != null)
        {
            text += "name=";
            text += "\"%s\";\n".printf (name);
        }

        if (field != null)
        {
            text += "field=";
            foreach (var v in field)
                text += "%s;\n".printf (v.to_string ());
        }

        if (extension != null)
        {
            text += "extension=";
            foreach (var v in extension)
                text += "%s;\n".printf (v.to_string ());
        }

        if (nested_type != null)
        {
            text += "nested_type=";
            foreach (var v in nested_type)
                text += "%s;\n".printf (v.to_string ());
        }

        if (enum_type != null)
        {
            text += "enum_type=";
            foreach (var v in enum_type)
                text += "%s;\n".printf (v.to_string ());
        }

        if (extension_range != null)
        {
            text += "extension_range=";
            foreach (var v in extension_range)
                text += "%s;\n".printf (v.to_string ());
        }

        if (options != null)
        {
            text += "options=";
            text += "%s;\n".printf (options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class FieldDescriptorProto
{
    public enum Type
    {
        TYPE_DOUBLE = 1,
        TYPE_FLOAT = 2,
        TYPE_INT64 = 3,
        TYPE_UINT64 = 4,
        TYPE_INT32 = 5,
        TYPE_FIXED64 = 6,
        TYPE_FIXED32 = 7,
        TYPE_BOOL = 8,
        TYPE_STRING = 9,
        TYPE_GROUP = 10,
        TYPE_MESSAGE = 11,
        TYPE_BYTES = 12,
        TYPE_UINT32 = 13,
        TYPE_ENUM = 14,
        TYPE_SFIXED32 = 15,
        TYPE_SFIXED64 = 16,
        TYPE_SINT32 = 17,
        TYPE_SINT64 = 18,
    }
    public enum Label
    {
        LABEL_OPTIONAL = 1,
        LABEL_REQUIRED = 2,
        LABEL_REPEATED = 3,
    }
    public string? name;
    public int32? number;
    public Label? label;
    public Type? type;
    public string? type_name;
    public string? extendee;
    public string? default_value;
    public FieldOptions? options;

    public FieldDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 3:
                number = varint;
                break;
            case 4:
                label = (Label) varint;
                break;
            case 5:
                type = (Type) varint;
                break;
            case 6:
                type_name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                extendee = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 7:
                default_value = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 8:
                options = new FieldOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of FieldDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (options != null)
        {
            var n = options.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (66, buffer, ref offset);
        }
        if (default_value != null)
        {
            var n = Protobuf.encode_string (default_value, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (58, buffer, ref offset);
        }
        if (extendee != null)
        {
            var n = Protobuf.encode_string (extendee, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (type_name != null)
        {
            var n = Protobuf.encode_string (type_name, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (50, buffer, ref offset);
        }
        if (type != null)
        {
            Protobuf.encode_varint (type, buffer, ref offset);
            Protobuf.encode_varint (40, buffer, ref offset);
        }
        if (label != null)
        {
            Protobuf.encode_varint (label, buffer, ref offset);
            Protobuf.encode_varint (32, buffer, ref offset);
        }
        if (number != null)
        {
            Protobuf.encode_varint (number, buffer, ref offset);
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        if (name != null)
        {
            var n = Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (name != null)
        {
            text += "name=";
            text += "\"%s\";\n".printf (name);
        }

        if (number != null)
        {
            text += "number=";
            text += "%s;\n".printf (number.to_string ());
        }

        if (label != null)
        {
            text += "label=";
            text += "%s;\n".printf (label.to_string ());
        }

        if (type != null)
        {
            text += "type=";
            text += "%s;\n".printf (type.to_string ());
        }

        if (type_name != null)
        {
            text += "type_name=";
            text += "\"%s\";\n".printf (type_name);
        }

        if (extendee != null)
        {
            text += "extendee=";
            text += "\"%s\";\n".printf (extendee);
        }

        if (default_value != null)
        {
            text += "default_value=";
            text += "\"%s\";\n".printf (default_value);
        }

        if (options != null)
        {
            text += "options=";
            text += "%s;\n".printf (options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class EnumDescriptorProto
{
    public string? name;
    public List<EnumValueDescriptorProto> value;
    public EnumOptions? options;

    public EnumDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                value.append (new EnumValueDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                options = new EnumOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of EnumDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (options != null)
        {
            var n = options.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        for (unowned List<EnumValueDescriptorProto> i = value.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (name != null)
        {
            var n = Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (name != null)
        {
            text += "name=";
            text += "\"%s\";\n".printf (name);
        }

        if (value != null)
        {
            text += "value=";
            foreach (var v in value)
                text += "%s;\n".printf (v.to_string ());
        }

        if (options != null)
        {
            text += "options=";
            text += "%s;\n".printf (options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class EnumValueDescriptorProto
{
    public string? name;
    public int32? number;
    public EnumValueOptions? options;

    public EnumValueDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                number = varint;
                break;
            case 3:
                options = new EnumValueOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of EnumValueDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (options != null)
        {
            var n = options.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        if (number != null)
        {
            Protobuf.encode_varint (number, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (name != null)
        {
            var n = Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (name != null)
        {
            text += "name=";
            text += "\"%s\";\n".printf (name);
        }

        if (number != null)
        {
            text += "number=";
            text += "%s;\n".printf (number.to_string ());
        }

        if (options != null)
        {
            text += "options=";
            text += "%s;\n".printf (options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class ServiceDescriptorProto
{
    public string? name;
    public List<MethodDescriptorProto> method;
    public ServiceOptions? options;

    public ServiceDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                method.append (new MethodDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                options = new ServiceOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (options != null)
        {
            var n = options.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        for (unowned List<MethodDescriptorProto> i = method.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (name != null)
        {
            var n = Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (name != null)
        {
            text += "name=";
            text += "\"%s\";\n".printf (name);
        }

        if (method != null)
        {
            text += "method=";
            foreach (var v in method)
                text += "%s;\n".printf (v.to_string ());
        }

        if (options != null)
        {
            text += "options=";
            text += "%s;\n".printf (options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class MethodDescriptorProto
{
    public string? name;
    public string? input_type;
    public string? output_type;
    public MethodOptions? options;

    public MethodDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                input_type = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 3:
                output_type = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 4:
                options = new MethodOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (options != null)
        {
            var n = options.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (34, buffer, ref offset);
        }
        if (output_type != null)
        {
            var n = Protobuf.encode_string (output_type, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        if (input_type != null)
        {
            var n = Protobuf.encode_string (input_type, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (name != null)
        {
            var n = Protobuf.encode_string (name, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (name != null)
        {
            text += "name=";
            text += "\"%s\";\n".printf (name);
        }

        if (input_type != null)
        {
            text += "input_type=";
            text += "\"%s\";\n".printf (input_type);
        }

        if (output_type != null)
        {
            text += "output_type=";
            text += "\"%s\";\n".printf (output_type);
        }

        if (options != null)
        {
            text += "options=";
            text += "%s;\n".printf (options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class FileOptions
{
    public enum OptimizeMode
    {
        SPEED = 1,
        CODE_SIZE = 2,
        LITE_RUNTIME = 3,
    }

    public string? java_package;
    public string? java_outer_classname;
    public bool? java_multiple_files;
    public bool? java_generate_equals_and_hash;
    public OptimizeMode? optimize_for;
    public bool? cc_generic_services;
    public bool? java_generic_services;
    public bool? py_generic_services;
    public List<UninterpretedOption> uninterpreted_option;

    public FileOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                java_package = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 8:
                java_outer_classname = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 10:
                java_multiple_files = varint != 0;
                break;
            case 20:
                java_generate_equals_and_hash = varint != 0;
                break;
            case 9:
                optimize_for = (OptimizeMode) varint;
                break;
            case 16:
                cc_generic_services = varint != 0;
                break;
            case 17:
                java_generic_services = varint != 0;
                break;
            case 18:
                py_generic_services = varint != 0;
                break;
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of EnumValueDescriptorProto\n", offset - length);
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = uninterpreted_option.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }
        if (py_generic_services != null)
        {
            Protobuf.encode_varint (py_generic_services ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (144, buffer, ref offset);
        }
        if (java_generic_services != null)
        {
            Protobuf.encode_varint (java_generic_services ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (136, buffer, ref offset);
        }
        if (cc_generic_services != null)
        {
            Protobuf.encode_varint (cc_generic_services ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (128, buffer, ref offset);
        }
        if (optimize_for != null)
        {
            Protobuf.encode_varint (optimize_for, buffer, ref offset);
            Protobuf.encode_varint (72, buffer, ref offset);
        }
        if (java_generate_equals_and_hash != null)
        {
            Protobuf.encode_varint (java_generate_equals_and_hash ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (160, buffer, ref offset);
        }
        if (java_multiple_files != null)
        {
            Protobuf.encode_varint (java_multiple_files ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (80, buffer, ref offset);
        }
        if (java_outer_classname != null)
        {
            var n = Protobuf.encode_string (java_outer_classname, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (66, buffer, ref offset);
        }
        if (java_package != null)
        {
            var n = Protobuf.encode_string (java_package, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (java_package != null)
        {
            text += "java_package=";
            text += "\"%s\";\n".printf (java_package);
        }

        if (java_outer_classname != null)
        {
            text += "java_outer_classname=";
            text += "\"%s\";\n".printf (java_outer_classname);
        }

        if (java_multiple_files != null)
        {
            text += "java_multiple_files=";
            text += "%s;\n".printf (java_multiple_files.to_string ());
        }

        if (java_generate_equals_and_hash != null)
        {
            text += "java_generate_equals_and_hash=";
            text += "%s;\n".printf (java_generate_equals_and_hash.to_string ());
        }

        if (optimize_for != null)
        {
            text += "optimize_for=";
            text += "%s;\n".printf (optimize_for.to_string ());
        }

        if (cc_generic_services != null)
        {
            text += "cc_generic_services=";
            text += "%s;\n".printf (cc_generic_services.to_string ());
        }

        if (java_generic_services != null)
        {
            text += "java_generic_services=";
            text += "%s;\n".printf (java_generic_services.to_string ());
        }

        if (py_generic_services != null)
        {
            text += "py_generic_services=";
            text += "%s;\n".printf (py_generic_services.to_string ());
        }

        if (uninterpreted_option != null)
        {
            text += "uninterpreted_option=";
            foreach (var v in uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class MessageOptions
{
    public bool? message_set_wire_format;
    public bool? no_standard_descriptor_accessor;
    public List<UninterpretedOption> uninterpreted_option;

    public MessageOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                message_set_wire_format = varint != 0;
                break;
            case 2:
                no_standard_descriptor_accessor = varint != 0;
                break;
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = uninterpreted_option.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }
        if (no_standard_descriptor_accessor != null)
        {
            Protobuf.encode_varint (no_standard_descriptor_accessor ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (message_set_wire_format != null)
        {
            Protobuf.encode_varint (message_set_wire_format ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (message_set_wire_format != null)
        {
            text += "message_set_wire_format=";
            text += "%s;\n".printf (message_set_wire_format.to_string ());
        }

        if (no_standard_descriptor_accessor != null)
        {
            text += "no_standard_descriptor_accessor=";
            text += "%s;\n".printf (no_standard_descriptor_accessor.to_string ());
        }

        if (uninterpreted_option != null)
        {
            text += "uninterpreted_option=";
            foreach (var v in uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class FieldOptions
{
    public enum CType
    {
        STRING = 0,
        CORD = 1,
        STRING_PIECE = 2,
    }

    public CType? ctype;
    public bool? packed;
    public bool? deprecated;
    public string? experimental_map_key;
    public List<UninterpretedOption> uninterpreted_option;

    public FieldOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                ctype = (CType) varint;
                break;
            case 2:
                packed = varint != 0;
                break;
            case 3:
                deprecated = varint != 0;
                break;
            case 9:
                experimental_map_key = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }

        if (offset != length)
            stderr.printf ("Unused %zu octets on end of FieldOptions\n", offset - length);
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = uninterpreted_option.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }
        if (experimental_map_key != null)
        {
            var n = Protobuf.encode_string (experimental_map_key, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (74, buffer, ref offset);
        }
        if (deprecated != null)
        {
            Protobuf.encode_varint (deprecated ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        if (packed != null)
        {
            Protobuf.encode_varint (packed ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (ctype != null)
        {
            Protobuf.encode_varint (ctype, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (ctype != null)
        {
            text += "ctype=";
            text += "%s;\n".printf (ctype.to_string ());
        }

        if (packed != null)
        {
            text += "packed=";
            text += "%s;\n".printf (packed.to_string ());
        }

        if (deprecated != null)
        {
            text += "deprecated=";
            text += "%s;\n".printf (deprecated.to_string ());
        }

        if (experimental_map_key != null)
        {
            text += "experimental_map_key=";
            text += "\"%s\";\n".printf (experimental_map_key);
        }

        if (uninterpreted_option != null)
        {
            text += "uninterpreted_option=";
            foreach (var v in uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class EnumOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public EnumOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = uninterpreted_option.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (uninterpreted_option != null)
        {
            text += "uninterpreted_option=";
            foreach (var v in uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class EnumValueOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public EnumValueOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = uninterpreted_option.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (uninterpreted_option != null)
        {
            text += "uninterpreted_option=";
            foreach (var v in uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class ServiceOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public ServiceOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = uninterpreted_option.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (uninterpreted_option != null)
        {
            text += "uninterpreted_option=";
            foreach (var v in uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class MethodOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public MethodOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = uninterpreted_option.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (uninterpreted_option != null)
        {
            text += "uninterpreted_option=";
            foreach (var v in uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class UninterpretedOption
{
    public class NamePart
    {
        public string name_part;
        public bool is_extension;

        public NamePart.from_data (uint8[] buffer, size_t length, size_t offset = 0)
        {
            decode (buffer, length, offset);
        }

        public void decode (uint8[] buffer, size_t length, size_t offset = 0)
        {
            while (offset < length)
            {
                var key = Protobuf.decode_varint (buffer, length, ref offset);
                var wire_type = key & 0x7;
                var field_number = key >> 3;
                int varint;
                var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
                // FIXME: Check remaining space

                switch (field_number)
                {
                case 1:
                    name_part = Protobuf.decode_string (buffer, offset + value_length, offset);
                    break;
                case 2:
                    is_extension = varint != 0;
                    break;
                }

                offset += value_length;
            }
        }

        public size_t encode (uint8[] buffer, ref size_t offset)
        {
            var start = offset;

            Protobuf.encode_varint (is_extension ? 1 : 0, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
            var n = Protobuf.encode_string (name_part, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);

            return start - offset;
        }

        public string to_string (string indent = "")
        {
            var text = "{\n";

            text += "name_part=";
            text += "\"%s\";\n".printf (name_part);

            text += "is_extension=";
            text += "%s;\n".printf (is_extension.to_string ());

            text += "}";
            return text;
        }
    }
    public List<NamePart> name;
    public string? identifier_value;
    public uint64? positive_int_value;
    public int64? negative_int_value;
    public double? double_value;
    public uint8[]? string_value;
    public string? aggregate_value;

    public UninterpretedOption.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 2:
                name.append (new NamePart.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                identifier_value = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 4:
                break;
            case 5:
                break;
            case 6:
                break;
            case 7:
                string_value = Protobuf.decode_bytes (buffer, offset + value_length, offset);
                break;
            case 8:
                aggregate_value = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (aggregate_value != null)
        {
            var n = Protobuf.encode_string (aggregate_value, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (66, buffer, ref offset);
        }
        if (string_value != null)
        {
            var n = Protobuf.encode_bytes (string_value, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (58, buffer, ref offset);
        }
        if (double_value != null)
        {
            // ...
            Protobuf.encode_varint (48, buffer, ref offset);
        }
        if (negative_int_value != null)
        {
            // ...
            Protobuf.encode_varint (40, buffer, ref offset);
        }
        if (positive_int_value != null)
        {
            // ...
            Protobuf.encode_varint (32, buffer, ref offset);
        }
        if (identifier_value != null)
        {
            var n = Protobuf.encode_string (identifier_value, buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        for (unowned List<NamePart> i = name.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (name != null)
        {
            text += "name=";
            foreach (var v in name)
                text += "%s;\n".printf (v.to_string ());
        }

        if (identifier_value != null)
        {
            text += "identifier_value=";
            text += "\"%s\";\n".printf (identifier_value);
        }

        if (positive_int_value != null)
        {
            text += "positive_int_value=";
            text += "%s;\n".printf (positive_int_value.to_string ());
        }

        if (negative_int_value != null)
        {
            text += "negative_int_value=";
            text += "%s;\n".printf (negative_int_value.to_string ());
        }

        if (double_value != null)
        {
            text += "double_value=";
            text += "%s;\n".printf (double_value.to_string ());
        }

        if (string_value != null)
        {
            text += "string_value=";
            //text += "%s;\n".printf (string_value.to_string ());
        }

        if (aggregate_value != null)
        {
            text += "aggregate_value=";
            text += "\"%s\";\n".printf (aggregate_value);
        }

        text += "}";
        return text;
    }
}

public class SourceCodeInfo
{
    public class Location
    {
        public List<int32> path;
        public List<int32> span;

        public Location.from_data (uint8[] buffer, size_t length, size_t offset = 0)
        {
            decode (buffer, length, offset);
        }

        public void decode (uint8[] buffer, size_t length, size_t offset = 0)
        {
            while (offset < length)
            {
                var key = Protobuf.decode_varint (buffer, length, ref offset);
                var wire_type = key & 0x7;
                var field_number = key >> 3;
                int varint;
                var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
                // FIXME: Check remaining space

                switch (field_number)
                {
                case 1:
                    path.append (varint);
                    break;
                case 2:
                    span.append (varint);
                    break;
                }

                offset += value_length;
            }
        }

        public size_t encode (uint8[] buffer, ref size_t offset)
        {
            var start = offset;

            for (unowned List<int32> i = span.last (); i != null; i = i.prev)
            {
                Protobuf.encode_varint (i.data, buffer, ref offset);
                Protobuf.encode_varint (16, buffer, ref offset);
            }
            for (unowned List<int32> i = path.last (); i != null; i = i.prev)
            {
                Protobuf.encode_varint (i.data, buffer, ref offset);
                Protobuf.encode_varint (8, buffer, ref offset);
            }

            return start - offset;
        }

        public string to_string (string indent = "")
        {
            var text = "{\n";

            if (path != null)
            {
                text += "path=";
                foreach (var v in path)
                    text += "%s;\n".printf (v.to_string ());
            }

            if (span != null)
            {
                text += "span=";
                foreach (var v in span)
                    text += "%s;\n".printf (v.to_string ());
            }

            text += "}";
            return text;
        }
    }
    public List<Location> location;

    public SourceCodeInfo.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                location.append (new Location.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<Location> i = location.last (); i != null; i = i.prev)
        {
            var n = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (n, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (location != null)
        {
            text += "location=";
            foreach (var v in location)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}
