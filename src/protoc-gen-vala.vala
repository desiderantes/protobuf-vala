public static int main (string[] args)
{
    var buf = new uint8[65535];
    var n_read = stdin.read (buf); // FIXME: Read all
    if (n_read < 0)
        return 1;
    buf.length = (int) n_read;

    var req = new CodeGeneratorRequest ();
    req.decode (buf, n_read);

    stderr.printf ("{ %s }\n", req.to_string ());

    var resp = new CodeGeneratorResponse ();
    
    foreach (var f in req.proto_file)
    {
        var out_file = new CodeGeneratorResponse.File ();

        if (f.name.has_suffix (".proto"))
            out_file.name = f.name.substring (0, f.name.length - 6) + ".pb.vala";
        else
            out_file.name = f.name + ".vala";
    
        out_file.content = "// Generated by protoc-gen-vala VERSION from %s, do not edit\n".printf (f.name);
        foreach (var enum_type in f.enum_type)
        {
            out_file.content += "\n";
            out_file.content += write_enum (enum_type);
        }
        foreach (var message_type in f.message_type)
        {
            out_file.content += "\n";
            out_file.content += write_class (message_type);
        }

        resp.file.append (out_file);
    }

    var resp_buf = new uint8[655350];
    size_t offset = resp_buf.length - 1;
    var n_written = resp.encode (resp_buf, ref offset);
    unowned uint8[] start = (uint8[]) ((uint8*) resp_buf + resp_buf.length - (int) n_written);
    start.length = (int) n_written;

    stdout.write (start);
    stdout.flush ();

    return 0;
}

private static string write_enum (EnumDescriptorProto type, string indent = "")
{
    var text = "";

    text += indent + "public enum %s\n".printf (type.name);
    text += indent + "{\n";
    foreach (var value in type.value)
        text += indent + "    %s = %d,\n".printf (value.name, value.number);
    text += indent + "}\n";

    return text;
}

private static string write_class (DescriptorProto type, string indent = "")
{
    var text = "";
    text += indent + "public class %s\n".printf (type.name);
    text += indent + "{\n";
    foreach (var enum_type in type.enum_type)
        text += write_enum (enum_type, indent + "    ");
    foreach (var nested_type in type.nested_type)
        text += write_class (nested_type, indent + "    ");
    foreach (var field in type.field)
        text += indent + "    public %s %s;\n".printf (get_type_name (field), field.name);
    text += "\n";
    text += indent + "    public %s.from_data (uint8[] buffer, size_t length, size_t offset = 0)\n".printf (type.name);
    text += indent + "    {\n";
    text += indent + "        decode (buffer, length, offset);\n";
    text += indent + "    }\n";
    text += "\n";
    text += indent + "    public void decode (uint8[] buffer, size_t length, size_t offset = 0)\n";
    text += indent + "    {\n";
    text += indent + "        while (offset < length)\n";
    text += indent + "        {\n";
    text += indent + "            var key = Protobuf.decode_varint (buffer, length, ref offset);\n";
    text += indent + "            var wire_type = key & 0x7;\n";
    text += indent + "            var field_number = key >> 3;\n";
    text += indent + "            int varint;\n";
    text += indent + "            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);\n";
    text += indent + "            // FIXME: Check remaining space\n";
    text += "\n";
    text += indent + "            switch (field_number)\n";
    text += indent + "            {\n";
    foreach (var field in type.field)
    {
        text += indent + "            case %d:\n".printf (field.number);
        var decode_method = "";
        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_DOUBLE:
            decode_method = "Protobuf.decode_double (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_FLOAT:
            decode_method = "Protobuf.decode_float (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_INT64:
            decode_method = "Protobuf.decode_int64 (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_UINT64:
            decode_method = "Protobuf.decode_uint64 (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_INT32:
            decode_method = "Protobuf.decode_int32 (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED64:
            decode_method = "Protobuf.decode_fixed64 (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED32:
            decode_method = "Protobuf.decode_fixed32 (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_BOOL:
            decode_method = "Protobuf.decode_bool (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_STRING:
            decode_method = "Protobuf.decode_string (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_BYTES:
            decode_method = "Protobuf.decode_bytes (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_MESSAGE:
            decode_method = "new %s.from_data (buffer, offset + value_length, offset)".printf (get_type_name (field, false));
            break;
        case FieldDescriptorProto.Type.TYPE_ENUM:
            decode_method = "(%s) varint".printf (get_type_name (field, false));
            break;
        case FieldDescriptorProto.Type.TYPE_UINT32:
            decode_method = "Protobuf.decode_uint32 (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED32:
            decode_method = "Protobuf.decode_sfixed32 (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED64:
            decode_method = "Protobuf.decode_sfixed64 (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_SINT32:
            decode_method = "Protobuf.decode_sint32 (buffer, offset + value_length, offset)";
            break;
        case FieldDescriptorProto.Type.TYPE_SINT64:
            decode_method = "Protobuf.decode_sint64 (buffer, offset + value_length, offset)";
            break;
        default:
            decode_method = "DECODE_UNKNOWN_TYPE%d ()".printf (field.type);
            break;
        }
        if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
            text += indent + "                this.%s.append (%s);\n".printf (field.name, decode_method);
        else
            text += indent + "                this.%s = %s;\n".printf (field.name, decode_method);
        text += indent + "                break;\n";
    }
    text += indent + "            }\n";
    text += "\n";
    text += indent + "            offset += value_length;\n";
    text += indent + "        }\n";
    // FIXME
    //
    //if (offset != length)
    //    stderr.printf ("Unused %zu octets on end of X\n", offset - length);
    //
    text += indent + "    }\n";
    text += "\n";
    text += indent + "    public size_t encode (uint8[] buffer, ref size_t offset)\n";
    text += indent + "    {\n";
    text += indent + "        var start = offset;\n";
    text += "\n";
    for (unowned List<FieldDescriptorProto> i = type.field.last (); i != null; i = i.prev)
    {
        var field = i.data;
        var indent2 = indent;
        var field_name = "this.%s".printf (field.name);
        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL)
        {
            text += indent + "        if (this.%s != null)\n".printf (field.name);
            text += indent + "        {\n";
            indent2 += "    ";
        }
        else if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
        {
            text += indent + "        for (unowned List<%s> i = this.%s.last (); i != null; i = i.prev)\n".printf (get_type_name (field, false), field.name);
            text += indent + "        {\n";
            indent2 += "    ";
            field_name = "i.data";
        }

        var encode_length = false;
        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_STRING:
        case FieldDescriptorProto.Type.TYPE_BYTES:
        case FieldDescriptorProto.Type.TYPE_MESSAGE:
            encode_length = true;
            break;
        }

        text += indent2 + "        ";
        if (encode_length)
            text += "var n = ";
        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_DOUBLE:
            text += "Protobuf.encode_double (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_FLOAT:
            text += "Protobuf.encode_float (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_INT64:
            text += "Protobuf.encode_int64 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_UINT64:
            text += "Protobuf.encode_uint64 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_INT32:
            text += "Protobuf.encode_int32 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED64:
            text += "Protobuf.encode_fixed64 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED32:
            text += "Protobuf.encode_fixed32 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_BOOL:
            text += "Protobuf.encode_bool (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_STRING:
            text += "Protobuf.encode_string (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_BYTES:
            text += "Protobuf.encode_bytes (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_UINT32:
            text += "Protobuf.encode_uint32 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED64:
            text += "Protobuf.encode_sfixed64 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED32:
            text += "Protobuf.encode_sfixed32 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SINT64:
            text += "Protobuf.encode_sint64 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SINT32:
            text += "Protobuf.encode_sint32 (%s, buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_MESSAGE:
            text += "%s.encode (buffer, ref offset);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_ENUM:
            text += "Protobuf.encode_varint (%s, buffer, ref offset);\n".printf (field_name);
            break;
        default:
            text += "ENCODE_UNKNOWN_TYPE%d (%s);\n".printf (field.type, field_name);
            break;
        }
        if (encode_length)
            text += indent2 + "        Protobuf.encode_varint (n, buffer, ref offset);\n";

        /* Encode key */
        var n = field.number << 3;
        if (encode_length)
            n |= 2;     
        text += indent2 + "        Protobuf.encode_varint (%d, buffer, ref offset);\n".printf (n);

        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL || field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
            text += indent + "        }\n";
    }
    text += "\n";
    text += indent + "        return start - offset;\n";
    text += indent + "    }\n";
    text += "\n";
    text += indent + "    public string to_string (string indent = \"\")\n";
    text += indent + "    {\n";
    text += indent + "        var text = \"{\\n\";\n";
    foreach (var field in type.field)
    {
        text += "\n";

        var indent2 = indent;
        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL || field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
        {
            text += indent + "        if (this.%s != null)\n".printf (field.name);
            text += indent + "        {\n";
            indent2 += "    ";
        }

        text += indent2 + "        text += \"%s = \";\n".printf (field.name);

        var field_name = "this.%s".printf (field.name);
        if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
        {
            text += indent2 + "        foreach (var v in this.%s)\n".printf (field.name);
            indent2 += "    ";
            field_name = "v";
        }

        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_STRING:
            text += indent2 + "        text += \"\\\"%%s\\\";\\n\".printf (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_BYTES:
            text += indent2 + "        for (var i = 0; i < %s.length; i++)\n".printf (field_name);
            text += indent2 + "            text += \"%%02X\".printf (%s[i]);\n".printf (field_name);
            text += indent2 + "        text += \"\\n\";\n";
            break;
        default:
            text += indent2 + "        text += \"%%s;\\n\".printf (%s.to_string ());\n".printf (field_name);
            break;
        }

        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL || field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
            text += indent + "        }\n";
    }
    text += "\n";
    text += indent + "        text += \"}\";\n";
    text += indent + "        return text;\n";
    text += indent + "    }\n";
    text += indent + "}\n";

    return text;
}

private static string get_type_name (FieldDescriptorProto field, bool full = true)
{
    var type_name = "";
    switch (field.type)
    {
    case FieldDescriptorProto.Type.TYPE_DOUBLE:
         type_name = "double";
         break;
    case FieldDescriptorProto.Type.TYPE_FLOAT:
         type_name = "float";
         break;
    case FieldDescriptorProto.Type.TYPE_INT64:
         type_name = "int64";
         break;
    case FieldDescriptorProto.Type.TYPE_UINT64:
         type_name = "uint64";
         break;
    case FieldDescriptorProto.Type.TYPE_INT32:
         type_name = "int32";
         break;
    case FieldDescriptorProto.Type.TYPE_BOOL:
         type_name = "bool";
         break;
    case FieldDescriptorProto.Type.TYPE_STRING:
         type_name = "string";
         break;
    case FieldDescriptorProto.Type.TYPE_BYTES:
         type_name = "uint8[]";
         break;
    case FieldDescriptorProto.Type.TYPE_UINT32:
         type_name = "uint32";
         break;
    case FieldDescriptorProto.Type.TYPE_MESSAGE:
    case FieldDescriptorProto.Type.TYPE_ENUM:
         type_name = field.type_name.substring (field.type_name.last_index_of (".") + 1);
         break;
    default:
         type_name = "UNKNOWN_TYPE%d".printf (field.type);
         break;
    }

    if (!full)
         return type_name;
    
    switch (field.label)
    {
    case FieldDescriptorProto.Label.LABEL_REPEATED:
        return "List<%s>".printf (type_name);
    case FieldDescriptorProto.Label.LABEL_OPTIONAL:
        return "%s?".printf (type_name);
    default:
    case FieldDescriptorProto.Label.LABEL_REQUIRED:
        return type_name;
    }
}
