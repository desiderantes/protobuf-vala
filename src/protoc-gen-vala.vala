extern const string VERSION;

public static int main (string[] args)
{
    var buf = new Protobuf.DecodeBuffer (65535);
    var n_read = stdin.read (buf.buffer); // FIXME: Read all
    if (n_read < 0)
        return 1;
    buf.buffer.length = (int) n_read;
    var req = new CodeGeneratorRequest ();
    req.decode (buf, n_read);

    stderr.printf ("{ %s }\n", req.to_string ());

    var resp = new CodeGeneratorResponse ();
    
    foreach (var f in req.proto_file)
    {
        var out_file = new CodeGeneratorResponse.File ();

        if (f.name.has_suffix (".proto"))
            out_file.name = f.name.substring (0, f.name.length - 6) + ".pb.vala";
        else
            out_file.name = f.name + ".vala";
    
        out_file.content = "// Generated by protoc-gen-vala %s from %s, do not edit\n".printf (VERSION, f.name);
        foreach (var enum_type in f.enum_type)
        {
            out_file.content += "\n";
            out_file.content += write_enum (enum_type);
        }
        foreach (var message_type in f.message_type)
        {
            out_file.content += "\n";
            out_file.content += write_class (message_type);
        }

        resp.file.append (out_file);
    }

    var resp_buf = new Protobuf.EncodeBuffer ();
    resp.encode (resp_buf);

    stdout.write (resp_buf.data);
    stdout.flush ();

    return 0;
}

private static string write_enum (EnumDescriptorProto type, string indent = "")
{
    var text = "";

    text += indent + "public enum %s\n".printf (type.name);
    text += indent + "{\n";
    foreach (var value in type.value)
        text += indent + "    %s = %d,\n".printf (value.name, value.number);
    text += indent + "}\n";

    return text;
}

private static string write_class (DescriptorProto type, string indent = "")
{
    var text = "";
    text += indent + "public class %s\n".printf (type.name);
    text += indent + "{\n";
    foreach (var enum_type in type.enum_type)
        text += write_enum (enum_type, indent + "    ");
    foreach (var nested_type in type.nested_type)
        text += write_class (nested_type, indent + "    ");
    foreach (var field in type.field)
        text += indent + "    public %s %s;\n".printf (get_type_name (field), field.name);
    text += "\n";
    text += indent + "    public %s.from_data (Protobuf.DecodeBuffer buffer, size_t data_length)\n".printf (type.name);
    text += indent + "    {\n";
    text += indent + "        decode (buffer, data_length);\n";
    text += indent + "    }\n";
    text += "\n";
    text += indent + "    public void decode (Protobuf.DecodeBuffer buffer, size_t data_length)\n";
    text += indent + "    {\n";
    text += indent + "        var end = buffer.read_index + data_length;\n";
    text += indent + "        while (buffer.read_index < end)\n";
    text += indent + "        {\n";
    text += indent + "            var key = buffer.decode_varint ();\n";
    text += indent + "            var wire_type = key & 0x7;\n";
    text += indent + "            var field_number = key >> 3;\n";
    text += "\n";
    var first = true;
    foreach (var field in type.field)
    {
        var decode_method = "";
        var wire_type = 0;
        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_DOUBLE:
            wire_type = 1;
            decode_method = "buffer.decode_double ()";
            break;
        case FieldDescriptorProto.Type.TYPE_FLOAT:
            wire_type = 5;
            decode_method = "buffer.decode_float ()";
            break;
        case FieldDescriptorProto.Type.TYPE_INT64:
            wire_type = 0;
            decode_method = "buffer.decode_int64 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_UINT64:
            wire_type = 0;
            decode_method = "buffer.decode_uint64 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_INT32:
            wire_type = 0;
            decode_method = "buffer.decode_int32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED64:
            wire_type = 1;
            decode_method = "buffer.decode_fixed64 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED32:
            wire_type = 5;
            decode_method = "buffer.decode_fixed32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_BOOL:
            wire_type = 0;
            decode_method = "buffer.decode_bool ()";
            break;
        case FieldDescriptorProto.Type.TYPE_STRING:
            wire_type = 2;
            decode_method = "buffer.decode_string ((size_t) buffer.decode_varint ())";
            break;
        case FieldDescriptorProto.Type.TYPE_BYTES:
            wire_type = 2;
            decode_method = "buffer.decode_bytes ((size_t) buffer.decode_varint ())";
            break;
        case FieldDescriptorProto.Type.TYPE_MESSAGE:
            wire_type = 2;
            decode_method = "new %s.from_data (buffer, (size_t) buffer.decode_varint ())".printf (get_type_name (field, false));
            break;
        case FieldDescriptorProto.Type.TYPE_ENUM:
            wire_type = 0;
            decode_method = "(%s) buffer.decode_varint ()".printf (get_type_name (field, false));
            break;
        case FieldDescriptorProto.Type.TYPE_UINT32:
            wire_type = 0;
            decode_method = "buffer.decode_uint32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED32:
            wire_type = 5;
            decode_method = "buffer.decode_sfixed32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED64:
            wire_type = 1;
            decode_method = "buffer.decode_sfixed64 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_SINT32:
            wire_type = 0;
            decode_method = "buffer.decode_sint32 ()";
            break;
        case FieldDescriptorProto.Type.TYPE_SINT64:
            wire_type = 0;
            decode_method = "buffer.decode_sint64 ()";
            break;
        default:
            // FIXME: Exit with error
            decode_method = "buffer.DECODE_UNKNOWN_TYPE%d ()".printf (field.type);
            break;
        }
        
        text += indent + "            %s (field_number == %d && wire_type == %d)\n".printf (first ? "if" : "else if", field.number, wire_type);
        if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
            text += indent + "                this.%s.append (%s);\n".printf (field.name, decode_method);
        else
            text += indent + "                this.%s = %s;\n".printf (field.name, decode_method);

        first = false;
    }
    text += indent + "            else\n";
    text += indent + "                buffer.decode_unknown (wire_type);\n";
    text += indent + "        }\n";
    // FIXME
    //
    //if (buffer.read_offset != end)
    //    stderr.printf ("Unused %zu octets on end of X\n", offset - length);
    //
    text += indent + "    }\n";
    text += "\n";
    text += indent + "    public size_t encode (Protobuf.EncodeBuffer buffer)\n";
    text += indent + "    {\n";
    text += indent + "        var start = buffer.write_index;\n";
    text += "\n";
    for (unowned List<FieldDescriptorProto> i = type.field.last (); i != null; i = i.prev)
    {
        var field = i.data;
        var indent2 = indent;
        var field_name = "this.%s".printf (field.name);
        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL)
        {
            text += indent + "        if (this.%s != null)\n".printf (field.name);
            text += indent + "        {\n";
            indent2 += "    ";
        }
        else if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
        {
            text += indent + "        for (unowned %s i = this.%s.last (); i != null; i = i.prev)\n".printf (get_type_name (field), field.name);
            text += indent + "        {\n";
            indent2 += "    ";
            field_name = "i.data";
        }

        var encode_length = false;
        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_STRING:
        case FieldDescriptorProto.Type.TYPE_BYTES:
        case FieldDescriptorProto.Type.TYPE_MESSAGE:
            encode_length = true;
            break;
        }

        text += indent2 + "        ";
        if (encode_length)
            text += "var %s_length = ".printf (field.name);
        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_DOUBLE:
            text += "buffer.encode_double (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_FLOAT:
            text += "buffer.encode_float (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_INT64:
            text += "buffer.encode_int64 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_UINT64:
            text += "buffer.encode_uint64 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_INT32:
            text += "buffer.encode_int32 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED64:
            text += "buffer.encode_fixed64 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_FIXED32:
            text += "buffer.encode_fixed32 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_BOOL:
            text += "buffer.encode_bool (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_STRING:
            text += "buffer.encode_string (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_BYTES:
            text += "buffer.encode_bytes (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_UINT32:
            text += "buffer.encode_uint32 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED64:
            text += "buffer.encode_sfixed64 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SFIXED32:
            text += "buffer.encode_sfixed32 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SINT64:
            text += "buffer.encode_sint64 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_SINT32:
            text += "buffer.encode_sint32 (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_MESSAGE:
            text += "%s.encode (buffer);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_ENUM:
            text += "buffer.encode_varint (%s);\n".printf (field_name);
            break;
        default:
            text += "ENCODE_UNKNOWN_TYPE%d (%s);\n".printf (field.type, field_name);
            break;
        }
        if (encode_length)
            text += indent2 + "        buffer.encode_varint (%s_length);\n".printf (field.name);

        /* Encode key */
        var n = field.number << 3;
        if (encode_length)
            n |= 2;     
        text += indent2 + "        buffer.encode_varint (%d);\n".printf (n);

        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL || field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
            text += indent + "        }\n";
    }
    text += "\n";
    text += indent + "        return start - buffer.write_index;\n";
    text += indent + "    }\n";
    text += "\n";
    text += indent + "    public string to_string (string indent = \"\")\n";
    text += indent + "    {\n";
    text += indent + "        var text = \"{\\n\";\n";
    foreach (var field in type.field)
    {
        text += "\n";

        var indent2 = indent;
        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL || field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
        {
            text += indent + "        if (this.%s != null)\n".printf (field.name);
            text += indent + "        {\n";
            indent2 += "    ";
        }

        text += indent2 + "        text += \"%s = \";\n".printf (field.name);

        var field_name = "this.%s".printf (field.name);
        if (field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
        {
            text += indent2 + "        foreach (unowned %s v in this.%s)\n".printf (get_type_name (field, false), field.name);
            indent2 += "    ";
            field_name = "v";
        }

        switch (field.type)
        {
        case FieldDescriptorProto.Type.TYPE_STRING:
            text += indent2 + "        text += \"\\\"%%s\\\";\\n\".printf (%s);\n".printf (field_name);
            break;
        case FieldDescriptorProto.Type.TYPE_BYTES:
            text += indent2 + "        for (var i = 0; i < %s.len; i++)\n".printf (field_name);
            text += indent2 + "            text += \"%%02X\".printf (%s.data[i]);\n".printf (field_name);
            text += indent2 + "        text += \"\\n\";\n";
            break;
        default:
            text += indent2 + "        text += \"%%s;\\n\".printf (%s.to_string ());\n".printf (field_name);
            break;
        }

        if (field.label == FieldDescriptorProto.Label.LABEL_OPTIONAL || field.label == FieldDescriptorProto.Label.LABEL_REPEATED)
            text += indent + "        }\n";
    }
    text += "\n";
    text += indent + "        text += \"}\";\n";
    text += indent + "        return text;\n";
    text += indent + "    }\n";
    text += indent + "}\n";

    return text;
}

private static string get_type_name (FieldDescriptorProto field, bool full = true)
{
    var type_name = "";
    var needs_box = false;
    switch (field.type)
    {
    case FieldDescriptorProto.Type.TYPE_DOUBLE:
        type_name = "double";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_FLOAT:
        type_name = "float";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_INT64:
        type_name = "int64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_UINT64:
        type_name = "uint64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_INT32:
        type_name = "int32";
        break;
    case FieldDescriptorProto.Type.TYPE_FIXED64:
        type_name = "uint64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_FIXED32:
        type_name = "uint32";
        break;
    case FieldDescriptorProto.Type.TYPE_BOOL:
        type_name = "bool";
        break;
    case FieldDescriptorProto.Type.TYPE_STRING:
        type_name = "string";
        break;
    case FieldDescriptorProto.Type.TYPE_BYTES:
        type_name = "GLib.ByteArray";
        break;
    case FieldDescriptorProto.Type.TYPE_UINT32:
        type_name = "uint32";
        break;
    case FieldDescriptorProto.Type.TYPE_SFIXED32:
        type_name = "int32";
        break;
    case FieldDescriptorProto.Type.TYPE_SFIXED64:
        type_name = "int64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_SINT32:
        type_name = "int32";
        break;
    case FieldDescriptorProto.Type.TYPE_SINT64:
        type_name = "int64";
        needs_box = true;
        break;
    case FieldDescriptorProto.Type.TYPE_MESSAGE:
    case FieldDescriptorProto.Type.TYPE_ENUM:
        type_name = field.type_name.substring (field.type_name.last_index_of (".") + 1);
        break;
    default:
        type_name = "UNKNOWN_TYPE%d".printf (field.type);
        break;
    }

    if (!full)
        return type_name;

    switch (field.label)
    {
    case FieldDescriptorProto.Label.LABEL_REPEATED:
        if (needs_box)
            return "List<%s?>".printf (type_name);
        else
            return "List<%s>".printf (type_name);
    case FieldDescriptorProto.Label.LABEL_OPTIONAL:
        return "%s?".printf (type_name);
    default:
    case FieldDescriptorProto.Label.LABEL_REQUIRED:
        return type_name;
    }
}
