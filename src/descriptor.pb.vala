// Generated by protoc-gen-vala 0.0.1 from google/protobuf/descriptor.proto, do not edit

public class FileDescriptorSet
{
    public List<FileDescriptorProto> file;

    public FileDescriptorSet.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.file.append (new FileDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<FileDescriptorProto> i = this.file.last (); i != null; i = i.prev)
        {
            var file_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (file_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.file != null)
        {
            text += "file = ";
            foreach (unowned FileDescriptorProto v in this.file)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class FileDescriptorProto
{
    public string? name;
    public string? package;
    public List<string> dependency;
    public List<DescriptorProto> message_type;
    public List<EnumDescriptorProto> enum_type;
    public List<ServiceDescriptorProto> service;
    public List<FieldDescriptorProto> extension;
    public FileOptions? options;
    public SourceCodeInfo? source_code_info;

    public FileDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                this.package = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 3:
                this.dependency.append (Protobuf.decode_string (buffer, offset + value_length, offset));
                break;
            case 4:
                this.message_type.append (new DescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 5:
                this.enum_type.append (new EnumDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 6:
                this.service.append (new ServiceDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 7:
                this.extension.append (new FieldDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 8:
                this.options = new FileOptions.from_data (buffer, offset + value_length, offset);
                break;
            case 9:
                this.source_code_info = new SourceCodeInfo.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (this.source_code_info != null)
        {
            var source_code_info_length = this.source_code_info.encode (buffer, ref offset);
            Protobuf.encode_varint (source_code_info_length, buffer, ref offset);
            Protobuf.encode_varint (74, buffer, ref offset);
        }
        if (this.options != null)
        {
            var options_length = this.options.encode (buffer, ref offset);
            Protobuf.encode_varint (options_length, buffer, ref offset);
            Protobuf.encode_varint (66, buffer, ref offset);
        }
        for (unowned List<FieldDescriptorProto> i = this.extension.last (); i != null; i = i.prev)
        {
            var extension_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (extension_length, buffer, ref offset);
            Protobuf.encode_varint (58, buffer, ref offset);
        }
        for (unowned List<ServiceDescriptorProto> i = this.service.last (); i != null; i = i.prev)
        {
            var service_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (service_length, buffer, ref offset);
            Protobuf.encode_varint (50, buffer, ref offset);
        }
        for (unowned List<EnumDescriptorProto> i = this.enum_type.last (); i != null; i = i.prev)
        {
            var enum_type_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (enum_type_length, buffer, ref offset);
            Protobuf.encode_varint (42, buffer, ref offset);
        }
        for (unowned List<DescriptorProto> i = this.message_type.last (); i != null; i = i.prev)
        {
            var message_type_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (message_type_length, buffer, ref offset);
            Protobuf.encode_varint (34, buffer, ref offset);
        }
        for (unowned List<string> i = this.dependency.last (); i != null; i = i.prev)
        {
            var dependency_length = Protobuf.encode_string (i.data, buffer, ref offset);
            Protobuf.encode_varint (dependency_length, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        if (this.package != null)
        {
            var package_length = Protobuf.encode_string (this.package, buffer, ref offset);
            Protobuf.encode_varint (package_length, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (this.name != null)
        {
            var name_length = Protobuf.encode_string (this.name, buffer, ref offset);
            Protobuf.encode_varint (name_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.name != null)
        {
            text += "name = ";
            text += "\"%s\";\n".printf (this.name);
        }

        if (this.package != null)
        {
            text += "package = ";
            text += "\"%s\";\n".printf (this.package);
        }

        if (this.dependency != null)
        {
            text += "dependency = ";
            foreach (unowned string v in this.dependency)
                text += "\"%s\";\n".printf (v);
        }

        if (this.message_type != null)
        {
            text += "message_type = ";
            foreach (unowned DescriptorProto v in this.message_type)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.enum_type != null)
        {
            text += "enum_type = ";
            foreach (unowned EnumDescriptorProto v in this.enum_type)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.service != null)
        {
            text += "service = ";
            foreach (unowned ServiceDescriptorProto v in this.service)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.extension != null)
        {
            text += "extension = ";
            foreach (unowned FieldDescriptorProto v in this.extension)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.options != null)
        {
            text += "options = ";
            text += "%s;\n".printf (this.options.to_string ());
        }

        if (this.source_code_info != null)
        {
            text += "source_code_info = ";
            text += "%s;\n".printf (this.source_code_info.to_string ());
        }

        text += "}";
        return text;
    }
}

public class DescriptorProto
{
    public class ExtensionRange
    {
        public int32? start;
        public int32? end;

        public ExtensionRange.from_data (uint8[] buffer, size_t length, size_t offset = 0)
        {
            decode (buffer, length, offset);
        }

        public void decode (uint8[] buffer, size_t length, size_t offset = 0)
        {
            while (offset < length)
            {
                var key = Protobuf.decode_varint (buffer, length, ref offset);
                var wire_type = key & 0x7;
                var field_number = key >> 3;
                int varint;
                var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
                // FIXME: Check remaining space

                switch (field_number)
                {
                case 1:
                    this.start = Protobuf.decode_int32 (buffer, offset + value_length, offset);
                    break;
                case 2:
                    this.end = Protobuf.decode_int32 (buffer, offset + value_length, offset);
                    break;
                }

                offset += value_length;
            }
        }

        public size_t encode (uint8[] buffer, ref size_t offset)
        {
            var start = offset;

            if (this.end != null)
            {
                Protobuf.encode_int32 (this.end, buffer, ref offset);
                Protobuf.encode_varint (16, buffer, ref offset);
            }
            if (this.start != null)
            {
                Protobuf.encode_int32 (this.start, buffer, ref offset);
                Protobuf.encode_varint (8, buffer, ref offset);
            }

            return start - offset;
        }

        public string to_string (string indent = "")
        {
            var text = "{\n";

            if (this.start != null)
            {
                text += "start = ";
                text += "%s;\n".printf (this.start.to_string ());
            }

            if (this.end != null)
            {
                text += "end = ";
                text += "%s;\n".printf (this.end.to_string ());
            }

            text += "}";
            return text;
        }
    }
    public string? name;
    public List<FieldDescriptorProto> field;
    public List<FieldDescriptorProto> extension;
    public List<DescriptorProto> nested_type;
    public List<EnumDescriptorProto> enum_type;
    public List<ExtensionRange> extension_range;
    public MessageOptions? options;

    public DescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                this.field.append (new FieldDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 6:
                this.extension.append (new FieldDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                this.nested_type.append (new DescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 4:
                this.enum_type.append (new EnumDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 5:
                this.extension_range.append (new ExtensionRange.from_data (buffer, offset + value_length, offset));
                break;
            case 7:
                this.options = new MessageOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (this.options != null)
        {
            var options_length = this.options.encode (buffer, ref offset);
            Protobuf.encode_varint (options_length, buffer, ref offset);
            Protobuf.encode_varint (58, buffer, ref offset);
        }
        for (unowned List<ExtensionRange> i = this.extension_range.last (); i != null; i = i.prev)
        {
            var extension_range_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (extension_range_length, buffer, ref offset);
            Protobuf.encode_varint (42, buffer, ref offset);
        }
        for (unowned List<EnumDescriptorProto> i = this.enum_type.last (); i != null; i = i.prev)
        {
            var enum_type_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (enum_type_length, buffer, ref offset);
            Protobuf.encode_varint (34, buffer, ref offset);
        }
        for (unowned List<DescriptorProto> i = this.nested_type.last (); i != null; i = i.prev)
        {
            var nested_type_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (nested_type_length, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        for (unowned List<FieldDescriptorProto> i = this.extension.last (); i != null; i = i.prev)
        {
            var extension_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (extension_length, buffer, ref offset);
            Protobuf.encode_varint (50, buffer, ref offset);
        }
        for (unowned List<FieldDescriptorProto> i = this.field.last (); i != null; i = i.prev)
        {
            var field_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (field_length, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (this.name != null)
        {
            var name_length = Protobuf.encode_string (this.name, buffer, ref offset);
            Protobuf.encode_varint (name_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.name != null)
        {
            text += "name = ";
            text += "\"%s\";\n".printf (this.name);
        }

        if (this.field != null)
        {
            text += "field = ";
            foreach (unowned FieldDescriptorProto v in this.field)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.extension != null)
        {
            text += "extension = ";
            foreach (unowned FieldDescriptorProto v in this.extension)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.nested_type != null)
        {
            text += "nested_type = ";
            foreach (unowned DescriptorProto v in this.nested_type)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.enum_type != null)
        {
            text += "enum_type = ";
            foreach (unowned EnumDescriptorProto v in this.enum_type)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.extension_range != null)
        {
            text += "extension_range = ";
            foreach (unowned ExtensionRange v in this.extension_range)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.options != null)
        {
            text += "options = ";
            text += "%s;\n".printf (this.options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class FieldDescriptorProto
{
    public enum Type
    {
        TYPE_DOUBLE = 1,
        TYPE_FLOAT = 2,
        TYPE_INT64 = 3,
        TYPE_UINT64 = 4,
        TYPE_INT32 = 5,
        TYPE_FIXED64 = 6,
        TYPE_FIXED32 = 7,
        TYPE_BOOL = 8,
        TYPE_STRING = 9,
        TYPE_GROUP = 10,
        TYPE_MESSAGE = 11,
        TYPE_BYTES = 12,
        TYPE_UINT32 = 13,
        TYPE_ENUM = 14,
        TYPE_SFIXED32 = 15,
        TYPE_SFIXED64 = 16,
        TYPE_SINT32 = 17,
        TYPE_SINT64 = 18,
    }
    public enum Label
    {
        LABEL_OPTIONAL = 1,
        LABEL_REQUIRED = 2,
        LABEL_REPEATED = 3,
    }
    public string? name;
    public int32? number;
    public Label? label;
    public Type? type;
    public string? type_name;
    public string? extendee;
    public string? default_value;
    public FieldOptions? options;

    public FieldDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 3:
                this.number = Protobuf.decode_int32 (buffer, offset + value_length, offset);
                break;
            case 4:
                this.label = (Label) varint;
                break;
            case 5:
                this.type = (Type) varint;
                break;
            case 6:
                this.type_name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                this.extendee = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 7:
                this.default_value = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 8:
                this.options = new FieldOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (this.options != null)
        {
            var options_length = this.options.encode (buffer, ref offset);
            Protobuf.encode_varint (options_length, buffer, ref offset);
            Protobuf.encode_varint (66, buffer, ref offset);
        }
        if (this.default_value != null)
        {
            var default_value_length = Protobuf.encode_string (this.default_value, buffer, ref offset);
            Protobuf.encode_varint (default_value_length, buffer, ref offset);
            Protobuf.encode_varint (58, buffer, ref offset);
        }
        if (this.extendee != null)
        {
            var extendee_length = Protobuf.encode_string (this.extendee, buffer, ref offset);
            Protobuf.encode_varint (extendee_length, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (this.type_name != null)
        {
            var type_name_length = Protobuf.encode_string (this.type_name, buffer, ref offset);
            Protobuf.encode_varint (type_name_length, buffer, ref offset);
            Protobuf.encode_varint (50, buffer, ref offset);
        }
        if (this.type != null)
        {
            Protobuf.encode_varint (this.type, buffer, ref offset);
            Protobuf.encode_varint (40, buffer, ref offset);
        }
        if (this.label != null)
        {
            Protobuf.encode_varint (this.label, buffer, ref offset);
            Protobuf.encode_varint (32, buffer, ref offset);
        }
        if (this.number != null)
        {
            Protobuf.encode_int32 (this.number, buffer, ref offset);
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        if (this.name != null)
        {
            var name_length = Protobuf.encode_string (this.name, buffer, ref offset);
            Protobuf.encode_varint (name_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.name != null)
        {
            text += "name = ";
            text += "\"%s\";\n".printf (this.name);
        }

        if (this.number != null)
        {
            text += "number = ";
            text += "%s;\n".printf (this.number.to_string ());
        }

        if (this.label != null)
        {
            text += "label = ";
            text += "%s;\n".printf (this.label.to_string ());
        }

        if (this.type != null)
        {
            text += "type = ";
            text += "%s;\n".printf (this.type.to_string ());
        }

        if (this.type_name != null)
        {
            text += "type_name = ";
            text += "\"%s\";\n".printf (this.type_name);
        }

        if (this.extendee != null)
        {
            text += "extendee = ";
            text += "\"%s\";\n".printf (this.extendee);
        }

        if (this.default_value != null)
        {
            text += "default_value = ";
            text += "\"%s\";\n".printf (this.default_value);
        }

        if (this.options != null)
        {
            text += "options = ";
            text += "%s;\n".printf (this.options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class EnumDescriptorProto
{
    public string? name;
    public List<EnumValueDescriptorProto> value;
    public EnumOptions? options;

    public EnumDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                this.value.append (new EnumValueDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                this.options = new EnumOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (this.options != null)
        {
            var options_length = this.options.encode (buffer, ref offset);
            Protobuf.encode_varint (options_length, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        for (unowned List<EnumValueDescriptorProto> i = this.value.last (); i != null; i = i.prev)
        {
            var value_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (value_length, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (this.name != null)
        {
            var name_length = Protobuf.encode_string (this.name, buffer, ref offset);
            Protobuf.encode_varint (name_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.name != null)
        {
            text += "name = ";
            text += "\"%s\";\n".printf (this.name);
        }

        if (this.value != null)
        {
            text += "value = ";
            foreach (unowned EnumValueDescriptorProto v in this.value)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.options != null)
        {
            text += "options = ";
            text += "%s;\n".printf (this.options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class EnumValueDescriptorProto
{
    public string? name;
    public int32? number;
    public EnumValueOptions? options;

    public EnumValueDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                this.number = Protobuf.decode_int32 (buffer, offset + value_length, offset);
                break;
            case 3:
                this.options = new EnumValueOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (this.options != null)
        {
            var options_length = this.options.encode (buffer, ref offset);
            Protobuf.encode_varint (options_length, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        if (this.number != null)
        {
            Protobuf.encode_int32 (this.number, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (this.name != null)
        {
            var name_length = Protobuf.encode_string (this.name, buffer, ref offset);
            Protobuf.encode_varint (name_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.name != null)
        {
            text += "name = ";
            text += "\"%s\";\n".printf (this.name);
        }

        if (this.number != null)
        {
            text += "number = ";
            text += "%s;\n".printf (this.number.to_string ());
        }

        if (this.options != null)
        {
            text += "options = ";
            text += "%s;\n".printf (this.options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class ServiceDescriptorProto
{
    public string? name;
    public List<MethodDescriptorProto> method;
    public ServiceOptions? options;

    public ServiceDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                this.method.append (new MethodDescriptorProto.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                this.options = new ServiceOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (this.options != null)
        {
            var options_length = this.options.encode (buffer, ref offset);
            Protobuf.encode_varint (options_length, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        for (unowned List<MethodDescriptorProto> i = this.method.last (); i != null; i = i.prev)
        {
            var method_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (method_length, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (this.name != null)
        {
            var name_length = Protobuf.encode_string (this.name, buffer, ref offset);
            Protobuf.encode_varint (name_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.name != null)
        {
            text += "name = ";
            text += "\"%s\";\n".printf (this.name);
        }

        if (this.method != null)
        {
            text += "method = ";
            foreach (unowned MethodDescriptorProto v in this.method)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.options != null)
        {
            text += "options = ";
            text += "%s;\n".printf (this.options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class MethodDescriptorProto
{
    public string? name;
    public string? input_type;
    public string? output_type;
    public MethodOptions? options;

    public MethodDescriptorProto.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.name = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 2:
                this.input_type = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 3:
                this.output_type = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 4:
                this.options = new MethodOptions.from_data (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (this.options != null)
        {
            var options_length = this.options.encode (buffer, ref offset);
            Protobuf.encode_varint (options_length, buffer, ref offset);
            Protobuf.encode_varint (34, buffer, ref offset);
        }
        if (this.output_type != null)
        {
            var output_type_length = Protobuf.encode_string (this.output_type, buffer, ref offset);
            Protobuf.encode_varint (output_type_length, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        if (this.input_type != null)
        {
            var input_type_length = Protobuf.encode_string (this.input_type, buffer, ref offset);
            Protobuf.encode_varint (input_type_length, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }
        if (this.name != null)
        {
            var name_length = Protobuf.encode_string (this.name, buffer, ref offset);
            Protobuf.encode_varint (name_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.name != null)
        {
            text += "name = ";
            text += "\"%s\";\n".printf (this.name);
        }

        if (this.input_type != null)
        {
            text += "input_type = ";
            text += "\"%s\";\n".printf (this.input_type);
        }

        if (this.output_type != null)
        {
            text += "output_type = ";
            text += "\"%s\";\n".printf (this.output_type);
        }

        if (this.options != null)
        {
            text += "options = ";
            text += "%s;\n".printf (this.options.to_string ());
        }

        text += "}";
        return text;
    }
}

public class FileOptions
{
    public enum OptimizeMode
    {
        SPEED = 1,
        CODE_SIZE = 2,
        LITE_RUNTIME = 3,
    }
    public string? java_package;
    public string? java_outer_classname;
    public bool? java_multiple_files;
    public bool? java_generate_equals_and_hash;
    public OptimizeMode? optimize_for;
    public bool? cc_generic_services;
    public bool? java_generic_services;
    public bool? py_generic_services;
    public List<UninterpretedOption> uninterpreted_option;

    public FileOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.java_package = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 8:
                this.java_outer_classname = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 10:
                this.java_multiple_files = Protobuf.decode_bool (buffer, offset + value_length, offset);
                break;
            case 20:
                this.java_generate_equals_and_hash = Protobuf.decode_bool (buffer, offset + value_length, offset);
                break;
            case 9:
                this.optimize_for = (OptimizeMode) varint;
                break;
            case 16:
                this.cc_generic_services = Protobuf.decode_bool (buffer, offset + value_length, offset);
                break;
            case 17:
                this.java_generic_services = Protobuf.decode_bool (buffer, offset + value_length, offset);
                break;
            case 18:
                this.py_generic_services = Protobuf.decode_bool (buffer, offset + value_length, offset);
                break;
            case 999:
                this.uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = this.uninterpreted_option.last (); i != null; i = i.prev)
        {
            var uninterpreted_option_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (uninterpreted_option_length, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }
        if (this.py_generic_services != null)
        {
            Protobuf.encode_bool (this.py_generic_services, buffer, ref offset);
            Protobuf.encode_varint (144, buffer, ref offset);
        }
        if (this.java_generic_services != null)
        {
            Protobuf.encode_bool (this.java_generic_services, buffer, ref offset);
            Protobuf.encode_varint (136, buffer, ref offset);
        }
        if (this.cc_generic_services != null)
        {
            Protobuf.encode_bool (this.cc_generic_services, buffer, ref offset);
            Protobuf.encode_varint (128, buffer, ref offset);
        }
        if (this.optimize_for != null)
        {
            Protobuf.encode_varint (this.optimize_for, buffer, ref offset);
            Protobuf.encode_varint (72, buffer, ref offset);
        }
        if (this.java_generate_equals_and_hash != null)
        {
            Protobuf.encode_bool (this.java_generate_equals_and_hash, buffer, ref offset);
            Protobuf.encode_varint (160, buffer, ref offset);
        }
        if (this.java_multiple_files != null)
        {
            Protobuf.encode_bool (this.java_multiple_files, buffer, ref offset);
            Protobuf.encode_varint (80, buffer, ref offset);
        }
        if (this.java_outer_classname != null)
        {
            var java_outer_classname_length = Protobuf.encode_string (this.java_outer_classname, buffer, ref offset);
            Protobuf.encode_varint (java_outer_classname_length, buffer, ref offset);
            Protobuf.encode_varint (66, buffer, ref offset);
        }
        if (this.java_package != null)
        {
            var java_package_length = Protobuf.encode_string (this.java_package, buffer, ref offset);
            Protobuf.encode_varint (java_package_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.java_package != null)
        {
            text += "java_package = ";
            text += "\"%s\";\n".printf (this.java_package);
        }

        if (this.java_outer_classname != null)
        {
            text += "java_outer_classname = ";
            text += "\"%s\";\n".printf (this.java_outer_classname);
        }

        if (this.java_multiple_files != null)
        {
            text += "java_multiple_files = ";
            text += "%s;\n".printf (this.java_multiple_files.to_string ());
        }

        if (this.java_generate_equals_and_hash != null)
        {
            text += "java_generate_equals_and_hash = ";
            text += "%s;\n".printf (this.java_generate_equals_and_hash.to_string ());
        }

        if (this.optimize_for != null)
        {
            text += "optimize_for = ";
            text += "%s;\n".printf (this.optimize_for.to_string ());
        }

        if (this.cc_generic_services != null)
        {
            text += "cc_generic_services = ";
            text += "%s;\n".printf (this.cc_generic_services.to_string ());
        }

        if (this.java_generic_services != null)
        {
            text += "java_generic_services = ";
            text += "%s;\n".printf (this.java_generic_services.to_string ());
        }

        if (this.py_generic_services != null)
        {
            text += "py_generic_services = ";
            text += "%s;\n".printf (this.py_generic_services.to_string ());
        }

        if (this.uninterpreted_option != null)
        {
            text += "uninterpreted_option = ";
            foreach (unowned UninterpretedOption v in this.uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class MessageOptions
{
    public bool? message_set_wire_format;
    public bool? no_standard_descriptor_accessor;
    public List<UninterpretedOption> uninterpreted_option;

    public MessageOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.message_set_wire_format = Protobuf.decode_bool (buffer, offset + value_length, offset);
                break;
            case 2:
                this.no_standard_descriptor_accessor = Protobuf.decode_bool (buffer, offset + value_length, offset);
                break;
            case 999:
                this.uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = this.uninterpreted_option.last (); i != null; i = i.prev)
        {
            var uninterpreted_option_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (uninterpreted_option_length, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }
        if (this.no_standard_descriptor_accessor != null)
        {
            Protobuf.encode_bool (this.no_standard_descriptor_accessor, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (this.message_set_wire_format != null)
        {
            Protobuf.encode_bool (this.message_set_wire_format, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.message_set_wire_format != null)
        {
            text += "message_set_wire_format = ";
            text += "%s;\n".printf (this.message_set_wire_format.to_string ());
        }

        if (this.no_standard_descriptor_accessor != null)
        {
            text += "no_standard_descriptor_accessor = ";
            text += "%s;\n".printf (this.no_standard_descriptor_accessor.to_string ());
        }

        if (this.uninterpreted_option != null)
        {
            text += "uninterpreted_option = ";
            foreach (unowned UninterpretedOption v in this.uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class FieldOptions
{
    public enum CType
    {
        STRING = 0,
        CORD = 1,
        STRING_PIECE = 2,
    }
    public CType? ctype;
    public bool? packed;
    public bool? deprecated;
    public string? experimental_map_key;
    public List<UninterpretedOption> uninterpreted_option;

    public FieldOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.ctype = (CType) varint;
                break;
            case 2:
                this.packed = Protobuf.decode_bool (buffer, offset + value_length, offset);
                break;
            case 3:
                this.deprecated = Protobuf.decode_bool (buffer, offset + value_length, offset);
                break;
            case 9:
                this.experimental_map_key = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 999:
                this.uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = this.uninterpreted_option.last (); i != null; i = i.prev)
        {
            var uninterpreted_option_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (uninterpreted_option_length, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }
        if (this.experimental_map_key != null)
        {
            var experimental_map_key_length = Protobuf.encode_string (this.experimental_map_key, buffer, ref offset);
            Protobuf.encode_varint (experimental_map_key_length, buffer, ref offset);
            Protobuf.encode_varint (74, buffer, ref offset);
        }
        if (this.deprecated != null)
        {
            Protobuf.encode_bool (this.deprecated, buffer, ref offset);
            Protobuf.encode_varint (24, buffer, ref offset);
        }
        if (this.packed != null)
        {
            Protobuf.encode_bool (this.packed, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
        }
        if (this.ctype != null)
        {
            Protobuf.encode_varint (this.ctype, buffer, ref offset);
            Protobuf.encode_varint (8, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.ctype != null)
        {
            text += "ctype = ";
            text += "%s;\n".printf (this.ctype.to_string ());
        }

        if (this.packed != null)
        {
            text += "packed = ";
            text += "%s;\n".printf (this.packed.to_string ());
        }

        if (this.deprecated != null)
        {
            text += "deprecated = ";
            text += "%s;\n".printf (this.deprecated.to_string ());
        }

        if (this.experimental_map_key != null)
        {
            text += "experimental_map_key = ";
            text += "\"%s\";\n".printf (this.experimental_map_key);
        }

        if (this.uninterpreted_option != null)
        {
            text += "uninterpreted_option = ";
            foreach (unowned UninterpretedOption v in this.uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class EnumOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public EnumOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                this.uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = this.uninterpreted_option.last (); i != null; i = i.prev)
        {
            var uninterpreted_option_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (uninterpreted_option_length, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.uninterpreted_option != null)
        {
            text += "uninterpreted_option = ";
            foreach (unowned UninterpretedOption v in this.uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class EnumValueOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public EnumValueOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                this.uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = this.uninterpreted_option.last (); i != null; i = i.prev)
        {
            var uninterpreted_option_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (uninterpreted_option_length, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.uninterpreted_option != null)
        {
            text += "uninterpreted_option = ";
            foreach (unowned UninterpretedOption v in this.uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class ServiceOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public ServiceOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                this.uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = this.uninterpreted_option.last (); i != null; i = i.prev)
        {
            var uninterpreted_option_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (uninterpreted_option_length, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.uninterpreted_option != null)
        {
            text += "uninterpreted_option = ";
            foreach (unowned UninterpretedOption v in this.uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class MethodOptions
{
    public List<UninterpretedOption> uninterpreted_option;

    public MethodOptions.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 999:
                this.uninterpreted_option.append (new UninterpretedOption.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<UninterpretedOption> i = this.uninterpreted_option.last (); i != null; i = i.prev)
        {
            var uninterpreted_option_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (uninterpreted_option_length, buffer, ref offset);
            Protobuf.encode_varint (7994, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.uninterpreted_option != null)
        {
            text += "uninterpreted_option = ";
            foreach (unowned UninterpretedOption v in this.uninterpreted_option)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}

public class UninterpretedOption
{
    public class NamePart
    {
        public string name_part;
        public bool is_extension;

        public NamePart.from_data (uint8[] buffer, size_t length, size_t offset = 0)
        {
            decode (buffer, length, offset);
        }

        public void decode (uint8[] buffer, size_t length, size_t offset = 0)
        {
            while (offset < length)
            {
                var key = Protobuf.decode_varint (buffer, length, ref offset);
                var wire_type = key & 0x7;
                var field_number = key >> 3;
                int varint;
                var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
                // FIXME: Check remaining space

                switch (field_number)
                {
                case 1:
                    this.name_part = Protobuf.decode_string (buffer, offset + value_length, offset);
                    break;
                case 2:
                    this.is_extension = Protobuf.decode_bool (buffer, offset + value_length, offset);
                    break;
                }

                offset += value_length;
            }
        }

        public size_t encode (uint8[] buffer, ref size_t offset)
        {
            var start = offset;

            Protobuf.encode_bool (this.is_extension, buffer, ref offset);
            Protobuf.encode_varint (16, buffer, ref offset);
            var name_part_length = Protobuf.encode_string (this.name_part, buffer, ref offset);
            Protobuf.encode_varint (name_part_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);

            return start - offset;
        }

        public string to_string (string indent = "")
        {
            var text = "{\n";

            text += "name_part = ";
            text += "\"%s\";\n".printf (this.name_part);

            text += "is_extension = ";
            text += "%s;\n".printf (this.is_extension.to_string ());

            text += "}";
            return text;
        }
    }
    public List<NamePart> name;
    public string? identifier_value;
    public uint64? positive_int_value;
    public int64? negative_int_value;
    public double? double_value;
    public GLib.ByteArray? string_value;
    public string? aggregate_value;

    public UninterpretedOption.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 2:
                this.name.append (new NamePart.from_data (buffer, offset + value_length, offset));
                break;
            case 3:
                this.identifier_value = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            case 4:
                this.positive_int_value = Protobuf.decode_uint64 (buffer, offset + value_length, offset);
                break;
            case 5:
                this.negative_int_value = Protobuf.decode_int64 (buffer, offset + value_length, offset);
                break;
            case 6:
                this.double_value = Protobuf.decode_double (buffer, offset + value_length, offset);
                break;
            case 7:
                this.string_value = Protobuf.decode_bytes (buffer, offset + value_length, offset);
                break;
            case 8:
                this.aggregate_value = Protobuf.decode_string (buffer, offset + value_length, offset);
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        if (this.aggregate_value != null)
        {
            var aggregate_value_length = Protobuf.encode_string (this.aggregate_value, buffer, ref offset);
            Protobuf.encode_varint (aggregate_value_length, buffer, ref offset);
            Protobuf.encode_varint (66, buffer, ref offset);
        }
        if (this.string_value != null)
        {
            var string_value_length = Protobuf.encode_bytes (this.string_value, buffer, ref offset);
            Protobuf.encode_varint (string_value_length, buffer, ref offset);
            Protobuf.encode_varint (58, buffer, ref offset);
        }
        if (this.double_value != null)
        {
            Protobuf.encode_double (this.double_value, buffer, ref offset);
            Protobuf.encode_varint (48, buffer, ref offset);
        }
        if (this.negative_int_value != null)
        {
            Protobuf.encode_int64 (this.negative_int_value, buffer, ref offset);
            Protobuf.encode_varint (40, buffer, ref offset);
        }
        if (this.positive_int_value != null)
        {
            Protobuf.encode_uint64 (this.positive_int_value, buffer, ref offset);
            Protobuf.encode_varint (32, buffer, ref offset);
        }
        if (this.identifier_value != null)
        {
            var identifier_value_length = Protobuf.encode_string (this.identifier_value, buffer, ref offset);
            Protobuf.encode_varint (identifier_value_length, buffer, ref offset);
            Protobuf.encode_varint (26, buffer, ref offset);
        }
        for (unowned List<NamePart> i = this.name.last (); i != null; i = i.prev)
        {
            var name_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (name_length, buffer, ref offset);
            Protobuf.encode_varint (18, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.name != null)
        {
            text += "name = ";
            foreach (unowned NamePart v in this.name)
                text += "%s;\n".printf (v.to_string ());
        }

        if (this.identifier_value != null)
        {
            text += "identifier_value = ";
            text += "\"%s\";\n".printf (this.identifier_value);
        }

        if (this.positive_int_value != null)
        {
            text += "positive_int_value = ";
            text += "%s;\n".printf (this.positive_int_value.to_string ());
        }

        if (this.negative_int_value != null)
        {
            text += "negative_int_value = ";
            text += "%s;\n".printf (this.negative_int_value.to_string ());
        }

        if (this.double_value != null)
        {
            text += "double_value = ";
            text += "%s;\n".printf (this.double_value.to_string ());
        }

        if (this.string_value != null)
        {
            text += "string_value = ";
            for (var i = 0; i < this.string_value.len; i++)
                text += "%02X".printf (this.string_value.data[i]);
            text += "\n";
        }

        if (this.aggregate_value != null)
        {
            text += "aggregate_value = ";
            text += "\"%s\";\n".printf (this.aggregate_value);
        }

        text += "}";
        return text;
    }
}

public class SourceCodeInfo
{
    public class Location
    {
        public List<int32> path;
        public List<int32> span;

        public Location.from_data (uint8[] buffer, size_t length, size_t offset = 0)
        {
            decode (buffer, length, offset);
        }

        public void decode (uint8[] buffer, size_t length, size_t offset = 0)
        {
            while (offset < length)
            {
                var key = Protobuf.decode_varint (buffer, length, ref offset);
                var wire_type = key & 0x7;
                var field_number = key >> 3;
                int varint;
                var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
                // FIXME: Check remaining space

                switch (field_number)
                {
                case 1:
                    this.path.append (Protobuf.decode_int32 (buffer, offset + value_length, offset));
                    break;
                case 2:
                    this.span.append (Protobuf.decode_int32 (buffer, offset + value_length, offset));
                    break;
                }

                offset += value_length;
            }
        }

        public size_t encode (uint8[] buffer, ref size_t offset)
        {
            var start = offset;

            for (unowned List<int32> i = this.span.last (); i != null; i = i.prev)
            {
                Protobuf.encode_int32 (i.data, buffer, ref offset);
                Protobuf.encode_varint (16, buffer, ref offset);
            }
            for (unowned List<int32> i = this.path.last (); i != null; i = i.prev)
            {
                Protobuf.encode_int32 (i.data, buffer, ref offset);
                Protobuf.encode_varint (8, buffer, ref offset);
            }

            return start - offset;
        }

        public string to_string (string indent = "")
        {
            var text = "{\n";

            if (this.path != null)
            {
                text += "path = ";
                foreach (unowned int32 v in this.path)
                    text += "%s;\n".printf (v.to_string ());
            }

            if (this.span != null)
            {
                text += "span = ";
                foreach (unowned int32 v in this.span)
                    text += "%s;\n".printf (v.to_string ());
            }

            text += "}";
            return text;
        }
    }
    public List<Location> location;

    public SourceCodeInfo.from_data (uint8[] buffer, size_t length, size_t offset = 0)
    {
        decode (buffer, length, offset);
    }

    public void decode (uint8[] buffer, size_t length, size_t offset = 0)
    {
        while (offset < length)
        {
            var key = Protobuf.decode_varint (buffer, length, ref offset);
            var wire_type = key & 0x7;
            var field_number = key >> 3;
            int varint;
            var value_length = Protobuf.get_value_length (wire_type, out varint, buffer, length, ref offset);
            // FIXME: Check remaining space

            switch (field_number)
            {
            case 1:
                this.location.append (new Location.from_data (buffer, offset + value_length, offset));
                break;
            }

            offset += value_length;
        }
    }

    public size_t encode (uint8[] buffer, ref size_t offset)
    {
        var start = offset;

        for (unowned List<Location> i = this.location.last (); i != null; i = i.prev)
        {
            var location_length = i.data.encode (buffer, ref offset);
            Protobuf.encode_varint (location_length, buffer, ref offset);
            Protobuf.encode_varint (10, buffer, ref offset);
        }

        return start - offset;
    }

    public string to_string (string indent = "")
    {
        var text = "{\n";

        if (this.location != null)
        {
            text += "location = ";
            foreach (unowned Location v in this.location)
                text += "%s;\n".printf (v.to_string ());
        }

        text += "}";
        return text;
    }
}
